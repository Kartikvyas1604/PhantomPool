# PhantomPool Backend - Complete Implementation Prompt
# For Claude Sonnet 4 / GitHub Copilot

You are an expert blockchain engineer specializing in zero-knowledge cryptography, decentralized finance, and Solana development. Your task is to build a complete, production-ready backend for PhantomPool - a zero-knowledge dark pool trading platform on Solana.

## TABLE OF CONTENTS
1. Project Overview & Architecture
2. Cryptographic Components Deep Dive
3. Backend Services Architecture
4. Database Schema & Data Models
5. API Endpoints Specification
6. Solana Smart Contract (Anchor)
7. Matching Engine Algorithm
8. Threshold Decryption Network
9. Jupiter Integration
10. Security & Error Handling
11. Testing Strategy
12. Deployment & DevOps

═══════════════════════════════════════════════════════════════════════════════
# PART 1: PROJECT OVERVIEW & ARCHITECTURE
═══════════════════════════════════════════════════════════════════════════════

## PROJECT MISSION
Build a trustless dark pool where large traders can execute orders without revealing them to the public until after execution. Solve the $2B+ monthly OTC trading problem on Solana by combining four cryptographic systems: homomorphic encryption, zero-knowledge proofs, verifiable random functions, and threshold cryptography.

## CORE INNOVATION
Unlike traditional dark pools (centralized, opaque), PhantomPool provides:
- **Cryptographic privacy**: Orders encrypted with ElGamal homomorphic encryption
- **Provable fairness**: VRF-based order shuffle prevents manipulation
- **Trustless execution**: Threshold secret sharing across 5 independent nodes
- **Transparent verification**: ZK proofs for every operation
- **MEV resistance**: Encrypted order book prevents front-running

## SYSTEM ARCHITECTURE

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              PHANTOMPOOL SYSTEM                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────┐      ┌──────────────┐      ┌──────────────┐             │
│  │   Frontend   │─────▶│ Order Relay  │─────▶│  Solana RPC  │             │
│  │  (Next.js)   │      │   Service    │      │   Endpoint   │             │
│  └──────────────┘      └──────────────┘      └──────────────┘             │
│                               │                                              │
│                               ▼                                              │
│                    ┌──────────────────────┐                                 │
│                    │  Encryption Service  │                                 │
│                    │  (ElGamal Encrypt)   │                                 │
│                    └──────────────────────┘                                 │
│                               │                                              │
│                               ▼                                              │
│              ┌────────────────────────────────────┐                         │
│              │   Encrypted Order Book (Redis)    │                         │
│              │  Orders stored as ciphertexts     │                         │
│              └────────────────────────────────────┘                         │
│                               │                                              │
│                               ▼                                              │
│                    ┌──────────────────────┐                                 │
│                    │  Matching Engine     │                                 │
│                    │  (VRF + Homomorphic) │                                 │
│                    └──────────────────────┘                                 │
│                               │                                              │
│                               ▼                                              │
│              ┌────────────────────────────────────┐                         │
│              │   Threshold Decryption Network    │                         │
│              │   5 Executors (3-of-5 required)   │                         │
│              └────────────────────────────────────┘                         │
│                               │                                              │
│                               ▼                                              │
│              ┌────────────────────────────────────┐                         │
│              │    Jupiter Aggregator SDK         │                         │
│              │    (Execute matched trades)       │                         │
│              └────────────────────────────────────┘                         │
│                               │                                              │
│                               ▼                                              │
│              ┌────────────────────────────────────┐                         │
│              │       Solana Blockchain           │                         │
│              │  (Anchor Program + Token Swaps)   │                         │
│              └────────────────────────────────────┘                         │
└─────────────────────────────────────────────────────────────────────────────┘
```

## TECHNOLOGY STACK

### Backend Framework
- **Node.js 20+ with TypeScript 5.3+**
- **Fastify 4.x** (high-performance web framework)
  - Handles 30k+ requests/sec
  - Built-in JSON schema validation
  - Excellent TypeScript support
  - Plugin ecosystem for modularity

### Database & Caching
- **PostgreSQL 15+** (persistent data: users, trades, audit logs)
- **Redis 7+** (in-memory encrypted order book, matching queue)
- **TimescaleDB extension** (time-series data for analytics)

### Cryptography Libraries
- **elliptic** - ElGamal encryption on secp256k1
- **bulletproofs** - Range proofs for solvency
- **@noble/curves** - Modern elliptic curve cryptography
- **@solana/web3.js** - Blockchain interaction
- **tweetnacl** - Ed25519 signatures for VRF
- **libsodium-wrappers** - Additional crypto primitives

### Solana Integration
- **@project-serum/anchor 0.29+** - Smart contract framework
- **@jup-ag/core** - Jupiter aggregator SDK
- **@solana/spl-token** - Token operations
- **@solana/web3.js 1.87+** - Solana SDK

### Monitoring & Observability
- **Prometheus** - Metrics collection
- **Grafana** - Visualization dashboards
- **Winston** - Structured logging
- **Sentry** - Error tracking
- **OpenTelemetry** - Distributed tracing

### Infrastructure
- **Docker** - Containerization
- **Kubernetes** - Orchestration for executor nodes
- **NGINX** - Reverse proxy & load balancing
- **Cloudflare** - DDoS protection

═══════════════════════════════════════════════════════════════════════════════
# PART 2: CRYPTOGRAPHIC COMPONENTS - DEEP DIVE
═══════════════════════════════════════════════════════════════════════════════

## 2.1 ELGAMAL HOMOMORPHIC ENCRYPTION

### Mathematical Foundation

ElGamal encryption operates on elliptic curves (secp256k1 - same as Bitcoin/Ethereum).

**Key Generation:**
1. Choose random private key: `sk ∈ [1, n-1]` where n is curve order
2. Compute public key: `pk = sk · G` where G is generator point
3. Public parameters: `(G, pk)`

**Encryption of value m:**
1. Choose random nonce: `r ∈ [1, n-1]`
2. Compute: `C1 = r · G`
3. Compute: `C2 = m · G + r · pk`
4. Ciphertext: `(C1, C2)`

**Homomorphic Property (THE KEY INNOVATION):**
- For ciphertexts `E(m1) = (C1₁, C2₁)` and `E(m2) = (C1₂, C2₂)`
- `E(m1) + E(m2) = (C1₁ + C1₂, C2₁ + C2₂) = E(m1 + m2)`
- **This allows aggregating orders WITHOUT decrypting individual orders!**

**Decryption:**
1. Compute: `M = C2 - sk · C1`
2. Solve discrete log: find `m` such that `m · G = M`
3. Use Baby-step Giant-step algorithm for small values

### Implementation Specifications

**File: `src/crypto/elgamal.service.ts`**

Create a comprehensive ElGamal service with the following methods:

```typescript
class ElGamalService {
  
  // 1. KEY GENERATION
  generateKeyPair(): ElGamalKeyPair
  /**
   * Generate new ElGamal keypair on secp256k1 curve
   * Steps:
   * - Use cryptographically secure random number generator
   * - Generate private key: randomBytes(32) mod n
   * - Compute public key: privateKey * G
   * - Validate key on curve
   * - Return both keys with metadata
   * 
   * Security: Private key must be stored in secure enclave (HSM in production)
   * In dev: Use environment variable ELGAMAL_PRIVATE_KEY
   */

  // 2. ORDER ENCRYPTION
  encryptOrder(order: PlainOrder, publicKey: ECPoint): EncryptedOrder
  /**
   * Encrypt order details using ElGamal
   * 
   * Input: PlainOrder {
   *   walletAddress: string;
   *   tokenPair: 'SOL/USDC';
   *   side: 'BUY' | 'SELL';
   *   amount: number;      // Amount of base token (e.g., 100 SOL)
   *   limitPrice: number;  // Price in quote token (e.g., 150 USDC)
   *   timestamp: number;
   *   nonce: string;       // Client-generated for uniqueness
   * }
   * 
   * Steps:
   * 1. Encode amount as elliptic curve point using Koblitz encoding:
   *    - Convert amount to integer (multiply by 1e6 for precision)
   *    - Find point on curve: try x = amount, check if x³ + 7 is quadratic residue
   *    - If not, try x = amount + 1, amount + 2, ... until valid point found
   * 
   * 2. Encrypt amount:
   *    - Generate random r_amount
   *    - C1_amount = r_amount * G
   *    - C2_amount = amountPoint + r_amount * publicKey
   * 
   * 3. Encrypt price similarly:
   *    - Generate random r_price
   *    - C1_price = r_price * G
   *    - C2_price = pricePoint + r_price * publicKey
   * 
   * 4. Create order hash:
   *    - orderHash = keccak256(C1_amount || C2_amount || C1_price || C2_price || timestamp || nonce)
   * 
   * 5. Sign order hash with wallet (for authentication):
   *    - signature = walletSign(orderHash)
   * 
   * Return: EncryptedOrder {
   *   orderHash: string;
   *   encryptedAmount: { C1: ECPoint, C2: ECPoint };
   *   encryptedPrice: { C1: ECPoint, C2: ECPoint };
   *   side: 'BUY' | 'SELL';
   *   tokenPair: string;
   *   timestamp: number;
   *   signature: string;
   *   publicKey: string; // For verification
   * }
   */

  // 3. HOMOMORPHIC AGGREGATION (CORE INNOVATION)
  aggregateOrders(encryptedOrders: EncryptedOrder[]): AggregatedCiphertext
  /**
   * Aggregate multiple encrypted orders using homomorphic property
   * 
   * Purpose: Compute total buy/sell volume WITHOUT decrypting individual orders
   * 
   * Steps:
   * 1. Separate orders by side (BUY vs SELL)
   * 
   * 2. For BUY orders, homomorphically add:
   *    - Sum all C1_amount: C1_buy_total = C1₁ + C1₂ + ... + C1ₙ
   *    - Sum all C2_amount: C2_buy_total = C2₁ + C2₂ + ... + C2ₙ
   *    - Result: E(total_buy_volume) = (C1_buy_total, C2_buy_total)
   * 
   * 3. For SELL orders, same process:
   *    - E(total_sell_volume) = (C1_sell_total, C2_sell_total)
   * 
   * 4. Compute weighted average price (homomorphically):
   *    - For each order: volume * price
   *    - Sum: E(Σ volume_i * price_i)
   *    - Divide by E(Σ volume_i) after decryption
   * 
   * Return: AggregatedCiphertext {
   *   buyVolume: { C1: ECPoint, C2: ECPoint };
   *   sellVolume: { C1: ECPoint, C2: ECPoint };
   *   weightedPriceSum: { C1: ECPoint, C2: ECPoint };
   *   orderCount: number;
   * }
   * 
   * Security: This reveals total volume but NOT individual order sizes
   */

  // 4. THRESHOLD DECRYPTION PREPARATION
  prepareThresholdShares(privateKey: bigint, threshold: number, totalShares: number): SecretShare[]
  /**
   * Split private key into shares using Shamir Secret Sharing
   * 
   * Purpose: No single executor can decrypt orders alone
   * Requires 3-of-5 executors to collaborate
   * 
   * Shamir Secret Sharing (t, n):
   * 1. Secret s (our private key)
   * 2. Choose random coefficients a₁, a₂, ..., a_{t-1}
   * 3. Construct polynomial: f(x) = s + a₁x + a₂x² + ... + a_{t-1}x^{t-1}
   * 4. Generate n shares: (i, f(i)) for i = 1, 2, ..., n
   * 5. Any t shares can reconstruct secret via Lagrange interpolation
   * 
   * Implementation:
   * - Use finite field arithmetic (mod curve order)
   * - Securely distribute shares to 5 executor nodes
   * - Each executor stores one share in encrypted storage
   * 
   * Return: SecretShare[] = [
   *   { executorId: 1, share: bigint, publicCommitment: ECPoint },
   *   { executorId: 2, share: bigint, publicCommitment: ECPoint },
   *   ...
   * ]
   */

  // 5. PARTIAL DECRYPTION (Run by each executor)
  partialDecrypt(ciphertext: Ciphertext, secretShare: bigint, shareIndex: number): PartialDecryption
  /**
   * Each executor contributes partial decryption using their share
   * 
   * Steps:
   * 1. Compute partial decryption: D_i = shareIndex * C1
   * 2. Generate ZK proof that D_i was computed correctly:
   *    - Prove: log_G(publicKey_i) = log_C1(D_i)
   *    - Use Schnorr protocol for proof
   * 
   * Return: PartialDecryption {
   *   executorId: number;
   *   partialValue: ECPoint;
   *   proof: SchnorrProof;
   * }
   */

  // 6. COMBINE PARTIAL DECRYPTIONS
  combinePartialDecryptions(partialDecryptions: PartialDecryption[], ciphertext: Ciphertext): PlainValue
  /**
   * Combine t (threshold) partial decryptions to recover plaintext
   * 
   * Steps:
   * 1. Verify each partial decryption proof (reject if invalid)
   * 2. Use Lagrange interpolation to combine:
   *    - Compute Lagrange coefficients: λ_i = Π_{j≠i} (j / (j - i))
   *    - Combine: D = Σ λ_i * D_i
   * 3. Compute plaintext point: M = C2 - D
   * 4. Solve discrete log to get value (Baby-step Giant-step)
   * 
   * Return: PlainValue {
   *   value: number;
   *   confidence: number; // 1.0 if all proofs valid
   * }
   */

  // 7. VERIFICATION UTILITIES
  verifyEncryption(ciphertext: Ciphertext, publicKey: ECPoint): boolean
  /**
   * Verify that ciphertext is well-formed
   * - Check that C1 and C2 are valid curve points
   * - Verify points are not at infinity
   * - Check order of points
   */

  // 8. RERANDOMIZATION (for privacy)
  rerandomize(ciphertext: Ciphertext, publicKey: ECPoint): Ciphertext
  /**
   * Rerandomize ciphertext for additional privacy
   * Purpose: Same plaintext, different ciphertext (unlinkability)
   * 
   * Steps:
   * 1. Generate random r'
   * 2. C1' = C1 + r' * G
   * 3. C2' = C2 + r' * publicKey
   * 
   * Property: (C1', C2') encrypts same value as (C1, C2)
   * Use case: Break linkability between order submission and matching
   */
}
```

**Key Data Structures:**

```typescript
interface ECPoint {
  x: string; // Hex-encoded coordinate
  y: string;
}

interface Ciphertext {
  C1: ECPoint;
  C2: ECPoint;
}

interface ElGamalKeyPair {
  privateKey: string; // Hex-encoded bigint
  publicKey: ECPoint;
  createdAt: number;
}

interface EncryptedOrder {
  orderHash: string;
  encryptedAmount: Ciphertext;
  encryptedPrice: Ciphertext;
  side: 'BUY' | 'SELL';
  tokenPair: string;
  timestamp: number;
  signature: string;
  walletAddress: string;
}
```

---

## 2.2 BULLETPROOFS+ FOR SOLVENCY PROOFS

### Purpose
Prove that traders have sufficient balance WITHOUT revealing exact amount.

**Example:**
- Trader claims to buy 100 SOL at 150 USDC each
- Must prove: balance ≥ 15,000 USDC
- Bulletproofs+ proves: "balance is in range [15000, 2^64]" with 0 knowledge

### Mathematical Foundation

**Range Proof Protocol:**
1. Prover wants to prove: v ∈ [0, 2^n]
2. Commitment: C = v*G + r*H (Pedersen commitment)
3. Prove v can be represented as n-bit binary
4. Proof size: O(log n) - much smaller than naive proofs

### Implementation Specifications

**File: `src/crypto/bulletproofs.service.ts`**

```typescript
class BulletproofsService {

  // 1. GENERATE SOLVENCY PROOF
  generateSolvencyProof(balance: number, requiredAmount: number): SolvencyProof
  /**
   * Generate zero-knowledge proof that balance ≥ requiredAmount
   * 
   * Steps:
   * 1. Compute proof value: proofValue = balance - requiredAmount
   *    (Must be non-negative for valid proof)
   * 
   * 2. Create Pedersen commitment:
   *    - Generate random blinding factor r
   *    - C = proofValue * G + r * H
   *    - H is second generator (nothing-up-my-sleeve)
   * 
   * 3. Generate Bulletproofs+ range proof:
   *    - Prove: proofValue ∈ [0, 2^64]
   *    - Use inner product argument
   *    - Proof size: ~700 bytes (logarithmic in range)
   * 
   * 4. Include commitment to actual balance (for auditing):
   *    - balanceCommitment = balance * G + r_balance * H
   * 
   * Return: SolvencyProof {
   *   commitment: ECPoint;          // C
   *   proof: Uint8Array;           // Bulletproofs+ proof
   *   balanceCommitment: ECPoint;  // For auditing
   *   requiredAmount: number;      // Public parameter
   *   timestamp: number;
   * }
   * 
   * Security: Reveals NOTHING about exact balance
   * Verifier learns only: balance ≥ requiredAmount
   */

  // 2. VERIFY SOLVENCY PROOF
  verifySolvencyProof(proof: SolvencyProof): boolean
  /**
   * Verify that proof is valid
   * 
   * Steps:
   * 1. Verify Bulletproofs+ range proof:
   *    - Check inner product argument
   *    - Verify commitment opens correctly
   *    - Ensure no overflow attacks
   * 
   * 2. Verify proof freshness (timestamp within 60 seconds)
   * 
   * 3. Check commitment is well-formed (valid curve point)
   * 
   * Return: true if proof is valid, false otherwise
   * 
   * Performance: ~2ms per proof verification
   */

  // 3. BATCH VERIFICATION (optimization)
  batchVerifyProofs(proofs: SolvencyProof[]): BatchVerificationResult
  /**
   * Verify multiple proofs efficiently
   * 
   * Optimization: Batch verification is ~5x faster than individual
   * 
   * Steps:
   * 1. Generate random challenges for each proof
   * 2. Compute linear combination of all proofs
   * 3. Verify combined proof (single pairing check)
   * 
   * Return: BatchVerificationResult {
   *   allValid: boolean;
   *   invalidIndices: number[];  // If any are invalid
   *   verificationTime: number;  // For metrics
   * }
   */

  // 4. AGGREGATE COMMITMENTS
  aggregateCommitments(commitments: ECPoint[]): ECPoint
  /**
   * Homomorphically combine balance commitments
   * 
   * Purpose: Prove total pool solvency without revealing individual balances
   * 
   * Steps:
   * 1. Sum all commitments: C_total = C₁ + C₂ + ... + Cₙ
   * 2. Property: C_total commits to sum of balances
   * 
   * Use case: Prove entire pool is solvent before matching
   */

  // 5. GENERATE AUDIT TOKEN
  generateAuditToken(proof: SolvencyProof, auditorPublicKey: ECPoint): EncryptedAuditToken
  /**
   * Create token that allows authorized auditor to verify exact balance
   * 
   * Purpose: Regulatory compliance while preserving privacy
   * 
   * Steps:
   * 1. Encrypt actual balance with auditor's public key
   * 2. Include proof that encrypted value matches commitment
   * 3. Auditor can decrypt and verify, but cannot share
   * 
   * Use case: Satisfy regulators without public disclosure
   */
}
```

---

## 2.3 VRF (VERIFIABLE RANDOM FUNCTION) FOR FAIR ORDERING

### Purpose
Randomly shuffle orders to prevent manipulation and ensure fairness.

**Problem without VRF:**
- Matching engine could favor certain orders
- Executor could see orders and manipulate shuffle
- No way to verify fairness

**Solution with VRF:**
- Randomness is unpredictable before reveal
- Anyone can verify randomness was generated correctly
- Deterministic: same input → same output (for reproducibility)

### Implementation Specifications

**File: `src/crypto/vrf.service.ts`**

```typescript
class VRFService {

  // 1. GENERATE VRF PROOF
  generateVRFProof(seed: string, privateKey: Uint8Array): VRFProof
  /**
   * Generate verifiable random function proof
   * 
   * VRF Construction (based on ECVRF-ED25519-SHA512-Elligator2):
   * 
   * Input:
   * - seed: Unique per matching round (e.g., blockhash + round number)
   * - privateKey: Executor's secret key
   * 
   * Steps:
   * 1. Hash seed to curve point: H = hashToCurve(seed)
   * 2. Compute VRF output: Γ = privateKey * H
   * 3. Generate proof of correct computation:
   *    - Use Chaum-Pedersen protocol
   *    - Prove: log_G(publicKey) = log_H(Γ)
   * 4. Derive random value: randomness = SHA512(Γ)
   * 
   * Return: VRFProof {
   *   output: Uint8Array;      // 64-byte random value
   *   proof: Uint8Array;       // 80-byte proof
   *   seed: string;            // Original seed
   *   publicKey: Uint8Array;   // For verification
   * }
   * 
   * Properties:
   * - Uniqueness: Only one valid output per (seed, privateKey) pair
   * - Collision-resistance: Different seeds → different outputs
   * - Pseudorandomness: Output indistinguishable from random
   */

  // 2. VERIFY VRF PROOF
  verifyVRFProof(proof: VRFProof): boolean
  /**
   * Verify that VRF output was generated correctly
   * 
   * Steps:
   * 1. Hash seed to curve point: H = hashToCurve(seed)
   * 2. Verify Chaum-Pedersen proof:
   *    - Check: e(G, Γ) = e(publicKey, H)
   *    - Where e is pairing function
   * 3. Recompute output: randomness = SHA512(Γ)
   * 4. Check output matches proof
   * 
   * Return: true if valid, false otherwise
   * 
   * Performance: ~5ms verification time
   */

  // 3. SHUFFLE ORDERS USING VRF
  shuffleOrders(orders: EncryptedOrder[], vrfOutput: Uint8Array): ShuffledOrders
  /**
   * Deterministically shuffle orders using VRF output as seed
   * 
   * Algorithm: Fisher-Yates shuffle with VRF seed
   * 
   * Steps:
   * 1. Use VRF output as seed for PRNG (ChaCha20)
   * 2. For i from n-1 down to 1:
   *    - j = random integer in [0, i] (using PRNG)
   *    - Swap orders[i] with orders[j]
   * 3. Store shuffle permutation for verification
   * 
   * Return: ShuffledOrders {
   *   orders: EncryptedOrder[];
   *   permutation: number[];        // Original indices
   *   shuffleProof: ShuffleProof;   // Proof of correct shuffle
   * }
   * 
   * Property: Anyone can verify same shuffle using VRF proof
   */

  // 4. GENERATE SHUFFLE PROOF
  generateShuffleProof(originalOrders: string[], shuffledOrders: string[], vrfProof: VRFProof): ShuffleProof
  /**
   * Prove that shuffle was performed correctly using VRF
   * 
   * Proof includes:
   * 1. VRF proof (proves randomness source)
   * 2. Commitment to original order
   * 3. Commitment to shuffled order
   * 4. ZK proof that one is permutation of other
   * 
   * Use case: Transparency - anyone can verify fair matching
   */

  // 5. GET NEXT VRF SEED
  getNextVRFSeed(currentBlockhash: string, roundNumber: number): string
  /**
   * Generate seed for next matching round
   * 
   * Seed = keccak256(currentBlockhash || roundNumber || timestamp)
   * 
   * Properties:
   * - Unique per round
   * - Unpredictable (uses future blockhash)
   * - Deterministic (for reproducibility)
   */
}
```

---

## 2.4 ZERO-KNOWLEDGE PROOF GENERATION

**File: `src/crypto/zkproof.service.ts`**

```typescript
class ZKProofService {

  // 1. GENERATE MATCHING PROOF
  generateMatchingProof(matchedOrders: MatchedPair[], clearingPrice: number): MatchingProof
  /**
   * Prove that order matching was performed correctly
   * 
   * Claims to prove:
   * 1. All buy orders have price ≥ clearingPrice
   * 2. All sell orders have price ≤ clearingPrice
   * 3. Volume matched is min(totalBuy, totalSell)
   * 4. No orders were excluded unfairly
   * 
   * Circuit constraints (in pseudocode):
   * 
   * for each buy order:
   *   assert(orderPrice >= clearingPrice)
   *   buyVolume += orderAmount
   * 
   * for each sell order:
   *   assert(orderPrice <= clearingPrice)
   *   sellVolume += orderAmount
   * 
   * matchedVolume = min(buyVolume, sellVolume)
   * assert(actualMatchedVolume == matchedVolume)
   * 
   * Use Groth16 or PLONK for proof generation
   * Proof size: ~200 bytes
   * Generation time: ~500ms
   */

  // 2. GENERATE EXECUTION PROOF
  generateExecutionProof(trades: ExecutedTrade[]): ExecutionProof
  /**
   * Prove trades were executed at clearing price
   * 
   * Claims:
   * 1. Each trade executed at clearingPrice
   * 2. Buyer received correct amount of tokens
   * 3. Seller received correct amount of tokens
   * 4. No funds were lost or created
   * 
   * Conservation law: Σ inputs = Σ outputs (+ fees)
   */

  // 3. VERIFY PROOF
  verifyProof(proof: ZKProof): boolean
  /**
   * Verify zero-knowledge proof
   * 
   * Uses Groth16 verification (very fast: ~2ms)
   * 
   * Steps:
   * 1. Check proof format
   * 2. Verify pairing equation
   * 3. Check public inputs match
   */
}
```

═══════════════════════════════════════════════════════════════════════════════
# PART 3: BACKEND SERVICES ARCHITECTURE
═══════════════════════════════════════════════════════════════════════════════

## 3.1 PROJECT STRUCTURE

```
phantompool-backend/
├── src/
│   ├── api/
│   │   ├── routes/
│   │   │   ├── orders.routes.ts        # Order submission endpoints
│   │   │   ├── matching.routes.ts      # Matching status & results
│   │   │   ├── proofs.routes.ts        # Proof verification
│   │   │   └── health.routes.ts        # Health checks
│   │   ├── middleware/
│   │   │   ├── auth.middleware.ts      # Wallet signature verification
│   │   │   ├── rateLimit.middleware.ts # Rate limiting
│   │   │   ├── validation.middleware.ts # Request validation
│   │   │   └── error.middleware.ts     # Error handling
│   │   └── controllers/
│   │       ├── order.controller.ts     # Order logic
│   │       ├── matching.controller.ts  # Matching logic
│   │       └── proof.controller.ts     # Proof generation
│   ├── crypto/
│   │   ├── elgamal.service.ts         # ElGamal encryption
│   │   ├── bulletproofs.service.ts    # Solvency proofs
│   │   ├── vrf.service.ts             # Fair ordering
│   │   ├── zkproof.service.ts         # ZK proof generation
│   │   └── threshold.service.ts       # Threshold cryptography
│   ├── matching/
│   │   ├── engine.service.ts          # Core matching algorithm
│   │   ├── orderbook.service.ts       # Order book management
│   │   ├── aggregation.service.ts     # Homomorphic aggregation
│   │   └── clearingPrice.service.ts   # Price discovery
│   ├── execution/
│   │   ├── executor.service.ts        # Threshold executor node
│   │   ├── coordinator.service.ts     # Coordinates 5 executors
│   │   ├── jupiter.service.ts         # Jupiter integration
│   │   └── settlement.service.ts      # On-chain settlement
│   ├── blockchain/
│   │   ├── solana.service.ts          # Solana RPC interaction
│   │   ├── program/                   # Anchor smart contract
│   │   │   ├── programs/
│   │   │   │   └── phantompool/
│   │   │   │       ├── src/
│   │   │   │       │   └── lib.rs     # Anchor program
│   │   │   │       └── Cargo.toml
│   │   │   ├── tests/
│   │   │   └── Anchor.toml
│   │   └── transactions.service.ts    # Transaction building
│   ├── database/
│   │   ├── postgres/
│   │   │   ├── models/
│   │   │   │   ├── Order.model.ts
│   │   │   │   ├── Trade.model.ts
│   │   │   │   ├── User.model.ts
│   │   │   │   └── Proof.model.ts
│   │   │   ├── repositories/
│   │   │   │   ├── order.repository.ts
│   │   │   │   └── trade.repository.ts
│   │   │   └── migrations/
│   │   └── redis/
│   │       ├── orderbook.cache.ts     # In-memory order book
│   │       └── matching.queue.ts      # Matching queue
│   ├── monitoring/
│   │   ├── metrics.service.ts         # Prometheus metrics
│   │   ├── logger.service.ts          # Winston logging
│   │   └── tracing.service.ts         # OpenTelemetry
│   ├── config/
│   │   ├── env.config.ts              # Environment variables
│   │   ├── database.config.ts         # DB configuration
│   │   └── constants.ts               # Constants
│   ├── types/
│   │   ├── order.types.ts
│   │   ├── crypto.types.ts
│   │   └── api.types.ts
│   └── utils/
│       ├── encoding.utils.ts          # Hex/Base64 encoding
│       ├── validation.utils.ts        # Input validation
│       └── math.utils.ts              # BigInt arithmetic
├── tests/
│   ├── unit/
│   │   ├── crypto/
│   │   ├── matching/
│   │   └── execution/
│   ├── integration/
│   │   └── api/
│   └── e2e/
│       └── fullFlow.test.ts
├── docker/
│   ├── Dockerfile.api
│   ├── Dockerfile.executor
│   └── docker-compose.yml
├── k8s/
│   ├── api-deployment.yaml
│   ├── executor-statefulset.yaml
│   ├── redis-deployment.yaml
│   └── postgres-deployment.yaml
├── scripts/
│   ├── setup-executors.ts             # Initialize 5 executor nodes
│   ├── generate-keys.ts               # Generate ElGamal keys
│   └── deploy-program.ts              # Deploy Anchor program
├── package.json
├── tsconfig.json
├── .env.example
└── README.md
```

## 3.2 MAIN APPLICATION SETUP

**File: `src/index.ts`**

```typescript
import Fastify from 'fastify';
import { initializeServices } from './services/initialization';
import { registerRoutes } from './api/routes';
import { registerMiddleware } from './api/middleware';
import { logger } from './monitoring/logger.service';
import { MetricsService } from './monitoring/metrics.service';
import { Config } from './config/env.config';

async function bootstrap() {
  // Initialize Fastify
  const fastify = Fastify({
    logger: false, // Use custom Winston logger
    trustProxy: true,
    bodyLimit: 1048576, // 1MB
  });

  try {
    // 1. Register middleware
    await registerMiddleware(fastify);

    // 2. Initialize all services
    logger.info('Initializing services...');
    const services = await initializeServices();
    
    // Make services available to routes
    fastify.decorate('services', services);

    // 3. Register routes
    await registerRoutes(fastify);

    // 4. Start Prometheus metrics server
    const metricsService = new MetricsService();
    await metricsService.start(9090);

    // 5. Start main API server
    const port = Config.PORT || 3000;
    await fastify.listen({ port, host: '0.0.0.0' });
    
    logger.info(`🚀 PhantomPool API running on port ${port}`);
    logger.info(`📊 Metrics available on port 9090`);
    
  } catch (err) {
    logger.error('Failed to start server:', err);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, shutting down gracefully...');
  await fastify.close();
  process.exit(0);
});

bootstrap();
```

**File: `src/services/initialization.ts`**

```typescript
/**
 * Initialize all backend services in correct order
 */
export async function initializeServices() {
  const logger = new LoggerService();
  
  // 1. Database connections
  logger.info('Connecting to databases...');
  const postgres = await connectPostgres();
  const redis = await connectRedis();
  
  // 2. Initialize cryptographic services
  logger.info('Initializing cryptographic services...');
  const elgamal = new ElGamalService();
  const bulletproofs = new BulletproofsService();
  const vrf = new VRFService();
  const zkproof = new ZKProofService();
  
  // Load or generate ElGamal keypair
  const elgamalKeys = await elgamal.loadOrGenerateKeys();
  logger.info(`ElGamal public key: ${elgamalKeys.publicKey}`);
  
  // 3. Initialize threshold network
  logger.info('Setting up threshold decryption network...');
  const thresholdService = new ThresholdService(elgamalKeys.privateKey);
  const secretShares = thresholdService.generateShares(3, 5); // 3-of-5
  
  // Distribute shares to 5 executor nodes
  await distributeSecretShares(secretShares);
  
  // 4. Initialize matching engine
  logger.info('Starting matching engine...');
  const matchingEngine = new MatchingEngineService({
    elgamal,
    vrf,
    zkproof,
    redis,
  });
  
  // 5. Initialize executor coordinator
  logger.info('Starting executor coordinator...');
  const executorCoordinator = new ExecutorCoordinatorService({
    thresholdService,
    postgres,
    redis,
  });
  
  // 6. Initialize Solana service
  logger.info('Connecting to Solana...');
  const solana = new SolanaService(Config.SOLANA_RPC_URL);
  await solana.verifyConnection();
  
  // 7. Initialize Jupiter service
  const jupiter = new JupiterService(solana);
  
  return {
    postgres,
    redis,
    elgamal,
    bulletproofs,
    vrf,
    zkproof,
    thresholdService,
    matchingEngine,
    executorCoordinator,
    solana,
    jupiter,
    logger,
  };
}
```

## 3.3 ORDER SUBMISSION SERVICE

**File: `src/api/controllers/order.controller.ts`**

```typescript
import { FastifyRequest, FastifyReply } from 'fastify';
import { OrderService } from '../../services/order.service';
import { ElGamalService } from '../../crypto/elgamal.service';
import { BulletproofsService } from '../../crypto/bulletproofs.service';

export class OrderController {
  constructor(
    private orderService: OrderService,
    private elgamal: ElGamalService,
    private bulletproofs: BulletproofsService,
  ) {}

  /**
   * Submit new encrypted order
   * 
   * POST /api/orders/submit
   * 
   * Request Body:
   * {
   *   walletAddress: string;
   *   tokenPair: 'SOL/USDC';
   *   side: 'BUY' | 'SELL';
   *   amount: number;
   *   limitPrice: number;
   *   balance: number;         // For solvency proof
   *   signature: string;       // Wallet signature
   * }
   * 
   * Response:
   * {
   *   success: true;
   *   orderHash: string;
   *   encryptedOrder: EncryptedOrder;
   *   solvencyProof: SolvencyProof;
   *   estimatedMatchTime: number; // seconds
   * }
   */
  async submitOrder(req: FastifyRequest, reply: FastifyReply) {
    const {
      walletAddress,
      tokenPair,
      side,
      amount,
      limitPrice,
      balance,
      signature,
    } = req.body as any;

    try {
      // 1. Validate signature
      const isValidSignature = await this.verifyWalletSignature(
        walletAddress,
        { tokenPair, side, amount, limitPrice },
        signature
      );
      
      if (!isValidSignature) {
        return reply.code(401).send({
          error: 'Invalid wallet signature',
        });
      }

      // 2. Generate solvency proof
      const requiredAmount = side === 'BUY' ? amount * limitPrice : amount;
      const solvencyProof = await this.bulletproofs.generateSolvencyProof(
        balance,
        requiredAmount
      );

      // Verify proof immediately (fail fast)
      const isProofValid = await this.bulletproofs.verifySolvencyProof(solvencyProof);
      if (!isProofValid) {
        return reply.code(400).send({
          error: 'Invalid solvency proof - insufficient balance',
        });
      }

      // 3. Encrypt order
      const publicKey = await this.elgamal.getPublicKey();
      const encryptedOrder = await this.elgamal.encryptOrder(
        {
          walletAddress,
          tokenPair,
          side,
          amount,
          limitPrice,
          timestamp: Date.now(),
          nonce: generateNonce(),
        },
        publicKey
      );

      // 4. Store in Redis order book
      await this.orderService.addToOrderBook(encryptedOrder, solvencyProof);

      // 5. Emit event for real-time updates
      await this.orderService.emitOrderReceived(encryptedOrder);

      // 6. Log metrics
      this.logOrderMetrics(side, amount, limitPrice);

      return reply.code(201).send({
        success: true,
        orderHash: encryptedOrder.orderHash,
        encryptedOrder,
        solvencyProof: {
          commitment: solvencyProof.commitment,
          requiredAmount,
          // Don't send full proof to client
        },
        estimatedMatchTime: 30, // 30 seconds per matching round
      });

    } catch (error) {
      req.log.error('Order submission failed:', error);
      return reply.code(500).send({
        error: 'Failed to submit order',
        message: error.message,
      });
    }
  }

  /**
   * Get order status
   * 
   * GET /api/orders/:orderHash
   */
  async getOrderStatus(req: FastifyRequest, reply: FastifyReply) {
    const { orderHash } = req.params as any;

    const order = await this.orderService.getOrder(orderHash);
    
    if (!order) {
      return reply.code(404).send({
        error: 'Order not found',
      });
    }

    return reply.send({
      orderHash,
      status: order.status, // 'PENDING' | 'MATCHED' | 'EXECUTED' | 'CANCELLED'
      submittedAt: order.timestamp,
      matchedAt: order.matchedAt,
      executedAt: order.executedAt,
      clearingPrice: order.clearingPrice,
      txSignature: order.txSignature,
    });
  }

  /**
   * Cancel order (before matching)
   * 
   * DELETE /api/orders/:orderHash
   */
  async cancelOrder(req: FastifyRequest, reply: FastifyReply) {
    const { orderHash } = req.params as any;
    const { walletAddress, signature } = req.body as any;

    // Verify ownership
    const order = await this.orderService.getOrder(orderHash);
    if (order.walletAddress !== walletAddress) {
      return reply.code(403).send({
        error: 'Not authorized to cancel this order',
      });
    }

    // Can only cancel if not yet matched
    if (order.status !== 'PENDING') {
      return reply.code(400).send({
        error: 'Order already matched or executed',
      });
    }

    await this.orderService.cancelOrder(orderHash);

    return reply.send({
      success: true,
      message: 'Order cancelled',
    });
  }

  /**
   * Get current order book (encrypted)
   * 
   * GET /api/orders/book/:tokenPair
   */
  async getOrderBook(req: FastifyRequest, reply: FastifyReply) {
    const { tokenPair } = req.params as any;

    const orderBook = await this.orderService.getOrderBook(tokenPair);

    return reply.send({
      tokenPair,
      buyOrders: orderBook.buyOrders.length,
      sellOrders: orderBook.sellOrders.length,
      orders: orderBook.orders.map(order => ({
        orderHash: order.orderHash,
        side: order.side,
        timestamp: order.timestamp,
        // Encrypted data not revealed
        encryptedAmount: order.encryptedAmount,
        encryptedPrice: order.encryptedPrice,
      })),
    });
  }

  private async verifyWalletSignature(
    walletAddress: string,
    orderData: any,
    signature: string
  ): Promise<boolean> {
    // Implement Solana signature verification
    // Message format: keccak256(orderData)
    // Verify using ed25519
    return true; // Placeholder
  }

  private logOrderMetrics(side: string, amount: number, limitPrice: number) {
    // Prometheus metrics
    orderSubmittedCounter.inc({ side });
    orderValueHistogram.observe(amount * limitPrice);
  }
}
```

**File: `src/services/order.service.ts`**

```typescript
import { Redis } from 'ioredis';
import { EncryptedOrder, SolvencyProof } from '../types';

export class OrderService {
  constructor(
    private redis: Redis,
    private postgres: PrismaClient,
  ) {}

  /**
   * Add order to in-memory order book (Redis)
   */
  async addToOrderBook(order: EncryptedOrder, solvencyProof: SolvencyProof) {
    const key = `orderbook:${order.tokenPair}:${order.side}`;
    
    // Store order with metadata
    const orderData = {
      ...order,
      solvencyProof: {
        commitment: solvencyProof.commitment,
        proof: Buffer.from(solvencyProof.proof).toString('base64'),
      },
      addedAt: Date.now(),
    };

    // Add to Redis sorted set (sorted by timestamp)
    await this.redis.zadd(
      key,
      order.timestamp,
      JSON.stringify(orderData)
    );

    // Also store in hash for quick lookup
    await this.redis.hset(
      `orders:${order.orderHash}`,
      'data',
      JSON.stringify(orderData)
    );

    // Persist to Postgres for audit trail
    await this.postgres.order.create({
      data: {
        orderHash: order.orderHash,
        walletAddress: order.walletAddress,
        tokenPair: order.tokenPair,
        side: order.side,
        encryptedAmount: JSON.stringify(order.encryptedAmount),
        encryptedPrice: JSON.stringify(order.encryptedPrice),
        timestamp: order.timestamp,
        status: 'PENDING',
      },
    });
  }

  /**
   * Get all pending orders for matching
   */
  async getPendingOrders(tokenPair: string): Promise<{
    buyOrders: EncryptedOrder[];
    sellOrders: EncryptedOrder[];
  }> {
    // Fetch from Redis
    const buyKey = `orderbook:${tokenPair}:BUY`;
    const sellKey = `orderbook:${tokenPair}:SELL`;

    const [buyOrdersRaw, sellOrdersRaw] = await Promise.all([
      this.redis.zrange(buyKey, 0, -1),
      this.redis.zrange(sellKey, 0, -1),
    ]);

    const buyOrders = buyOrdersRaw.map(o => JSON.parse(o));
    const sellOrders = sellOrdersRaw.map(o => JSON.parse(o));

    return { buyOrders, sellOrders };
  }

  /**
   * Remove matched orders from order book
   */
  async removeMatchedOrders(orderHashes: string[]) {
    const pipeline = this.redis.pipeline();

    for (const orderHash of orderHashes) {
      const orderData = await this.redis.hget(`orders:${orderHash}`, 'data');
      if (orderData) {
        const order = JSON.parse(orderData);
        const key = `orderbook:${order.tokenPair}:${order.side}`;
        
        pipeline.zrem(key, orderData);
        pipeline.del(`orders:${orderHash}`);
      }
    }

    await pipeline.exec();

    // Update status in Postgres
    await this.postgres.order.updateMany({
      where: { orderHash: { in: orderHashes } },
      data: { status: 'MATCHED', matchedAt: new Date() },
    });
  }
}
```

═══════════════════════════════════════════════════════════════════════════════
# PART 4: MATCHING ENGINE - CORE ALGORITHM
═══════════════════════════════════════════════════════════════════════════════

**File: `src/matching/engine.service.ts`**

```typescript
import { ElGamalService } from '../crypto/elgamal.service';
import { VRFService } from '../crypto/vrf.service';
import { ZKProofService } from '../crypto/zkproof.service';
import { OrderService } from '../services/order.service';

export class MatchingEngineService {
  private matchingInterval: NodeJS.Timeout | null = null;
  private isMatching: boolean = false;

  constructor(
    private elgamal: ElGamalService,
    private vrf: VRFService,
    private zkproof: ZKProofService,
    private orderService: OrderService,
  ) {}

  /**
   * Start periodic matching (every 30 seconds)
   */
  start() {
    this.matchingInterval = setInterval(
      () => this.runMatchingRound(),
      30000 // 30 seconds
    );
    
    console.log('✅ Matching engine started (30s intervals)');
  }

  stop() {
    if (this.matchingInterval) {
      clearInterval(this.matchingInterval);
    }
  }

  /**
   * Main matching round algorithm
   * 
   * Steps:
   * 1. Fetch all pending orders from Redis
   * 2. Generate VRF proof and shuffle orders
   * 3. Homomorphically aggregate encrypted orders
   * 4. Decrypt aggregated volumes (threshold decryption)
   * 5. Calculate clearing price
   * 6. Match orders at clearing price
   * 7. Generate ZK proof of correct matching
   * 8. Trigger execution
   */
  async runMatchingRound() {
    if (this.isMatching) {
      console.log('⏭️  Skipping round - previous matching still in progress');
      return;
    }

    this.isMatching = true;
    const roundStartTime = Date.now();

    try {
      console.log('\n🔄 Starting matching round...');

      // ══════════════════════════════════════════════════════════════
      // STEP 1: Fetch pending orders
      // ══════════════════════════════════════════════════════════════
      const { buyOrders, sellOrders } = await this.orderService.getPendingOrders('SOL/USDC');

      if (buyOrders.length === 0 || sellOrders.length === 0) {
        console.log('ℹ️  No orders to match');
        this.isMatching = false;
        return;
      }

      console.log(`📊 Orders: ${buyOrders.length} buys, ${sellOrders.length} sells`);

      // ══════════════════════════════════════════════════════════════
      // STEP 2: VRF Shuffle for fairness
      // ══════════════════════════════════════════════════════════════
      const vrfSeed = await this.vrf.getNextVRFSeed(
        await this.getSolanaBlockhash(),
        roundStartTime
      );

      const vrfProof = await this.vrf.generateVRFProof(
        vrfSeed,
        this.getVRFPrivateKey()
      );

      // Verify VRF proof
      if (!await this.vrf.verifyVRFProof(vrfProof)) {
        throw new Error('VRF proof verification failed');
      }

      // Shuffle orders using VRF output
      const shuffledBuys = await this.vrf.shuffleOrders(buyOrders, vrfProof.output);
      const shuffledSells = await this.vrf.shuffleOrders(sellOrders, vrfProof.output);

      console.log('✅ Orders shuffled with VRF');

      // ══════════════════════════════════════════════════════════════
      // STEP 3: Homomorphic Aggregation
      // ══════════════════════════════════════════════════════════════
      const aggregatedBuys = await this.elgamal.aggregateOrders(shuffledBuys.orders);
      const aggregatedSells = await this.elgamal.aggregateOrders(shuffledSells.orders);

      console.log('✅ Orders aggregated homomorphically');

      // ══════════════════════════════════════════════════════════════
      // STEP 4: Threshold Decryption
      // ══════════════════════════════════════════════════════════════
      // Request partial decryptions from 5 executors
      const buyVolumeDecrypted = await this.requestThresholdDecryption(
        aggregatedBuys.buyVolume
      );

      const sellVolumeDecrypted = await this.requestThresholdDecryption(
        aggregatedSells.sellVolume
      );

      console.log(`✅ Decrypted volumes: ${buyVolumeDecrypted} buys, ${sellVolumeDecrypted} sells`);

      // ══════════════════════════════════════════════════════════════
      // STEP 5: Calculate Clearing Price
      // ══════════════════════════════════════════════════════════════
      const clearingPrice = await this.calculateClearingPrice(
        shuffledBuys.orders,
        shuffledSells.orders,
        buyVolumeDecrypted,
        sellVolumeDecrypted
      );

      console.log(`💰 Clearing price: ${clearingPrice} USDC`);

      // ══════════════════════════════════════════════════════════════
      // STEP 6: Match Orders
      // ══════════════════════════════════════════════════════════════
      const matchedPairs = await this.matchOrdersAtClearingPrice(
        shuffledBuys.orders,
        shuffledSells.orders,
        clearingPrice
      );

      console.log(`✅ Matched ${matchedPairs.length} order pairs`);

      // ══════════════════════════════════════════════════════════════
      // STEP 7: Generate ZK Proof of Correct Matching
      // ══════════════════════════════════════════════════════════════
      const matchingProof = await this.zkproof.generateMatchingProof(
        matchedPairs,
        clearingPrice
      );

      // Verify proof immediately
      if (!await this.zkproof.verifyProof(matchingProof)) {
        throw new Error('Matching proof verification failed');
      }

      console.log('✅ ZK proof generated and verified');

      // ══════════════════════════════════════════════════════════════
      // STEP 8: Trigger Execution
      // ══════════════════════════════════════════════════════════════
      await this.triggerExecution(matchedPairs, clearingPrice, matchingProof);

      const roundDuration = Date.now() - roundStartTime;
      console.log(`✅ Matching round completed in ${roundDuration}ms\n`);

      // Emit metrics
      this.emitMatchingMetrics(matchedPairs.length, clearingPrice, roundDuration);

    } catch (error) {
      console.error('❌ Matching round failed:', error);
      // Log error but don't crash - try again next round
    } finally {
      this.isMatching = false;
    }
  }

  /**
   * Calculate clearing price using decrypted aggregates
   * 
   * Algorithm: Find price where supply meets demand
   */
  private async calculateClearingPrice(
    buyOrders: EncryptedOrder[],
    sellOrders: EncryptedOrder[],
    totalBuyVolume: number,
    totalSellVolume: number
  ): Promise<number> {
    // Need to decrypt individual prices to find clearing price
    // This is done via threshold decryption
    
    const buyPrices = await this.decryptPrices(buyOrders.map(o => o.encryptedPrice));
    const sellPrices = await this.decryptPrices(sellOrders.map(o => o.encryptedPrice));

    // Sort buy prices descending (highest willing to pay first)
    const sortedBuys = buyPrices.sort((a, b) => b - a);
    
    // Sort sell prices ascending (lowest willing to sell first)
    const sortedSells = sellPrices.sort((a, b) => a - b);

    // Find intersection point
    let clearingPrice = 0;
    let maxVolume = 0;

    for (let i = 0; i < sortedBuys.length; i++) {
      for (let j = 0; j < sortedSells.length; j++) {
        if (sortedBuys[i] >= sortedSells[j]) {
          const price = (sortedBuys[i] + sortedSells[j]) / 2;
          const volume = Math.min(
            this.volumeAtPrice(buyOrders, buyPrices, price),
            this.volumeAtPrice(sellOrders, sellPrices, price)
          );

          if (volume > maxVolume) {
            maxVolume = volume;
            clearingPrice = price;
          }
        }
      }
    }

    return clearingPrice;
  }

  /**
   * Match orders at clearing price
   */
  private async matchOrdersAtClearingPrice(
    buyOrders: EncryptedOrder[],
    sellOrders: EncryptedOrder[],
    clearingPrice: number
  ): Promise<MatchedPair[]> {
    const matchedPairs: MatchedPair[] = [];

    // Decrypt prices and amounts for matching
    const decryptedBuys = await this.decryptOrders(buyOrders);
    const decryptedSells = await this.decryptOrders(sellOrders);

    // Filter orders that can match at clearing price
    const validBuys = decryptedBuys.filter(o => o.price >= clearingPrice);
    const validSells = decryptedSells.filter(o => o.price <= clearingPrice);

    // Simple matching: pair up orders
    let buyIndex = 0;
    let sellIndex = 0;
    let buyRemaining = validBuys[0]?.amount || 0;
    let sellRemaining = validSells[0]?.amount || 0;

    while (buyIndex < validBuys.length && sellIndex < validSells.length) {
      const matchAmount = Math.min(buyRemaining, sellRemaining);

      matchedPairs.push({
        buyOrder: buyOrders[buyIndex],
        sellOrder: sellOrders[sellIndex],
        amount: matchAmount,
        price: clearingPrice,
      });

      buyRemaining -= matchAmount;
      sellRemaining -= matchAmount;

      if (buyRemaining === 0) {
        buyIndex++;
        buyRemaining = validBuys[buyIndex]?.amount || 0;
      }

      if (sellRemaining === 0) {
        sellIndex++;
        sellRemaining = validSells[sellIndex]?.amount || 0;
      }
    }

    return matchedPairs;
  }

  /**
   * Request threshold decryption from 5 executor nodes
   */
  private async requestThresholdDecryption(ciphertext: Ciphertext): Promise<number> {
    // Contact all 5 executor nodes
    const executorUrls = [
      'http://executor-1:4001',
      'http://executor-2:4002',
      'http://executor-3:4003',
      'http://executor-4:4004',
      'http://executor-5:4005',
    ];

    // Request partial decryptions (need at least 3)
    const partialDecryptions = await Promise.all(
      executorUrls.map(url => 
        this.requestPartialDecryption(url, ciphertext)
      )
    );

    // Filter out failed requests
    const validDecryptions = partialDecryptions.filter(d => d !== null);

    if (validDecryptions.length < 3) {
      throw new Error(`Insufficient executors responded (got ${validDecryptions.length}, need 3)`);
    }

    // Combine first 3 valid partial decryptions
    const combined = await this.elgamal.combinePartialDecryptions(
      validDecryptions.slice(0, 3),
      ciphertext
    );

    return combined.value;
  }

  private async requestPartialDecryption(
    executorUrl: string,
    ciphertext: Ciphertext
  ): Promise<PartialDecryption | null> {
    try {
      const response = await fetch(`${executorUrl}/decrypt`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ciphertext }),
        timeout: 5000, // 5 second timeout
      });

      if (!response.ok) return null;

      return await response.json();
    } catch (error) {
      console.warn(`Executor ${executorUrl} failed:`, error.message);
      return null;
    }
  }

  private async decryptOrders(orders: EncryptedOrder[]): Promise<DecryptedOrder[]> {
    return Promise.all(
      orders.map(async (order) => {
        const amount = await this.requestThresholdDecryption(order.encryptedAmount);
        const price = await this.requestThresholdDecryption(order.encryptedPrice);
        
        return {
          orderHash: order.orderHash,
          walletAddress: order.walletAddress,
          side: order.side,
          amount,
          price,
          timestamp: order.timestamp,
        };
      })
    );
  }

  private async triggerExecution(
    matchedPairs: MatchedPair[],
    clearingPrice: number,
    proof: MatchingProof
  ) {
    // Send to executor coordinator
    await fetch('http://executor-coordinator:5000/execute', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        matchedPairs,
        clearingPrice,
        proof,
        timestamp: Date.now(),
      }),
    });
  }

  private emitMatchingMetrics(
    matchedCount: number,
    clearingPrice: number,
    duration: number
  ) {
    matchingRoundCounter.inc();
    matchedOrdersGauge.set(matchedCount);
    clearingPriceGauge.set(clearingPrice);
    matchingDurationHistogram.observe(duration / 1000);
  }
}
```

═══════════════════════════════════════════════════════════════════════════════
# PART 5: THRESHOLD DECRYPTION NETWORK
═══════════════════════════════════════════════════════════════════════════════

## 5.1 Executor Node Service

**File: `src/execution/executor.service.ts`**

```typescript
import { ThresholdService } from '../crypto/threshold.service';
import Fastify from 'fastify';

/**
 * Individual executor node
 * 
 * Each executor:
 * - Stores one secret share
 * - Provides partial decryptions
 * - Participates in trade execution
 * - Maintains uptime for redundancy
 */
export class ExecutorNode {
  private fastify: Fastify.FastifyInstance;
  private secretShare: bigint;
  private executorId: number;

  constructor(executorId: number, secretShare: bigint) {
    this.executorId = executorId;
    this.secretShare = secretShare;
    this.fastify = Fastify({ logger: true });
    
    this.registerRoutes();
  }

  private registerRoutes() {
    /**
     * Health check
     */
    this.fastify.get('/health', async () => {
      return {
        status: 'healthy',
        executorId: this.executorId,
        uptime: process.uptime(),
        timestamp: Date.now(),
      };
    });

    /**
     * Provide partial decryption
     * 
     * POST /decrypt
     * Body: { ciphertext: { C1: ECPoint, C2: ECPoint } }
     */
    this.fastify.post('/decrypt', async (request, reply) => {
      const { ciphertext } = request.body as any;

      try {
        // 1. Validate ciphertext
        if (!this.isValidCiphertext(ciphertext)) {
          return reply.code(400).send({
            error: 'Invalid ciphertext',
          });
        }

        // 2. Compute partial decryption
        const partialDecryption = await this.computePartialDecryption(ciphertext);

        // 3. Generate ZK proof of correctness
        const proof = await this.generateDecryptionProof(
          ciphertext,
          partialDecryption
        );

        return {
          executorId: this.executorId,
          partialDecryption,
          proof,
          timestamp: Date.now(),
        };

      } catch (error) {
        request.log.error('Decryption failed:', error);
        return reply.code(500).send({
          error: 'Decryption failed',
        });
      }
    });

    /**
     * Sign execution transaction
     * 
     * POST /sign-execution
     * Body: { transaction: string, matchProof: ZKProof }
     */
    this.fastify.post('/sign-execution', async (request, reply) => {
      const { transaction, matchProof } = request.body as any;

      try {
        // 1. Verify matching proof
        const isValidProof = await this.verifyMatchingProof(matchProof);
        if (!isValidProof) {
          return reply.code(400).send({
            error: 'Invalid matching proof',
          });
        }

        // 2. Validate transaction
        const isValidTx = await this.validateTransaction(transaction);
        if (!isValidTx) {
          return reply.code(400).send({
            error: 'Invalid transaction',
          });
        }

        // 3. Sign transaction with executor key
        const signature = await this.signTransaction(transaction);

        return {
          executorId: this.executorId,
          signature,
          timestamp: Date.now(),
        };

      } catch (error) {
        request.log.error('Signing failed:', error);
        return reply.code(500).send({
          error: 'Signing failed',
        });
      }
    });
  }

  /**
   * Compute partial decryption using secret share
   */
  private async computePartialDecryption(ciphertext: Ciphertext): Promise<ECPoint> {
    // D_i = secretShare * C1
    const { C1 } = ciphertext;
    
    const partialDecryption = this.scalarMultiply(C1, this.secretShare);
    
    return partialDecryption;
  }

  /**
   * Generate Schnorr proof that partial decryption is correct
   * 
   * Prove: log_G(publicKeyShare_i) = log_C1(D_i)
   */
  private async generateDecryptionProof(
    ciphertext: Ciphertext,
    partialDecryption: ECPoint
  ): Promise<SchnorrProof> {
    // Schnorr protocol:
    // 1. Choose random k
    // 2. Compute R = k * G, R' = k * C1
    // 3. Compute challenge: c = Hash(G || C1 || publicKeyShare || D_i || R || R')
    // 4. Compute response: s = k + c * secretShare
    // 
    // Proof: (c, s)
    // Verifier checks: s*G = R + c*publicKeyShare AND s*C1 = R' + c*D_i

    const k = this.randomScalar();
    const G = this.getGenerator();
    
    const R = this.scalarMultiply(G, k);
    const R_prime = this.scalarMultiply(ciphertext.C1, k);
    
    const publicKeyShare = this.scalarMultiply(G, this.secretShare);
    
    const challenge = this.hashToScalar([
      G,
      ciphertext.C1,
      publicKeyShare,
      partialDecryption,
      R,
      R_prime,
    ]);
    
    const response = (k + challenge * this.secretShare) % this.getCurveOrder();
    
    return {
      challenge: challenge.toString(16),
      response: response.toString(16),
      publicKeyShare: this.pointToHex(publicKeyShare),
    };
  }

  async start(port: number) {
    await this.fastify.listen({ port, host: '0.0.0.0' });
    console.log(`✅ Executor ${this.executorId} running on port ${port}`);
  }

  private isValidCiphertext(ciphertext: any): boolean {
    return (
      ciphertext &&
      ciphertext.C1 &&
      ciphertext.C2 &&
      this.isValidPoint(ciphertext.C1) &&
      this.isValidPoint(ciphertext.C2)
    );
  }

  private isValidPoint(point: ECPoint): boolean {
    // Check if point is on curve: y² = x³ + 7 (secp256k1)
    // Implement curve equation validation
    return true; // Placeholder
  }

  private scalarMultiply(point: ECPoint, scalar: bigint): ECPoint {
    // Implement elliptic curve scalar multiplication
    // Use double-and-add algorithm
    return point; // Placeholder
  }

  private randomScalar(): bigint {
    // Generate cryptographically secure random scalar
    const bytes = crypto.randomBytes(32);
    return BigInt('0x' + bytes.toString('hex')) % this.getCurveOrder();
  }

  private hashToScalar(data: any[]): bigint {
    const hash = crypto.createHash('sha256');
    data.forEach(item => hash.update(JSON.stringify(item)));
    return BigInt('0x' + hash.digest('hex')) % this.getCurveOrder();
  }

  private getCurveOrder(): bigint {
    // secp256k1 curve order
    return BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
  }

  private getGenerator(): ECPoint {
    // secp256k1 generator point
    return {
      x: '79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798',
      y: '483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8',
    };
  }

  private pointToHex(point: ECPoint): string {
    return `04${point.x}${point.y}`; // Uncompressed format
  }
}
```

## 5.2 Executor Coordinator

**File: `src/execution/coordinator.service.ts`**

```typescript
import { JupiterService } from './jupiter.service';
import { SolanaService } from '../blockchain/solana.service';

/**
 * Coordinates execution across 5 executor nodes
 * 
 * Responsibilities:
 * - Collect signatures from executors (need 3-of-5)
 * - Route trades through Jupiter
 * - Submit transactions to Solana
 * - Monitor execution status
 */
export class ExecutorCoordinatorService {
  private executorUrls = [
    'http://executor-1:4001',
    'http://executor-2:4002',
    'http://executor-3:4003',
    'http://executor-4:4004',
    'http://executor-5:4005',
  ];

  constructor(
    private jupiter: JupiterService,
    private solana: SolanaService,
    private postgres: PrismaClient,
  ) {}

  /**
   * Execute matched trades
   * 
   * Steps:
   * 1. Validate matching proof
   * 2. Build Solana transactions
   * 3. Get signatures from 3-of-5 executors
   * 4. Submit to blockchain
   * 5. Monitor settlement
   */
  async executeMatchedTrades(request: ExecutionRequest) {
    const { matchedPairs, clearingPrice, proof } = request;

    console.log(`\n🚀 Executing ${matchedPairs.length} matched trades...`);

    try {
      // ══════════════════════════════════════════════════════════════
      // STEP 1: Validate matching proof
      // ══════════════════════════════════════════════════════════════
      const isValidProof = await this.validateMatchingProof(proof);
      if (!isValidProof) {
        throw new Error('Invalid matching proof');
      }

      // ══════════════════════════════════════════════════════════════
      // STEP 2: Build transactions for each matched pair
      // ══════════════════════════════════════════════════════════════
      const transactions = await this.buildExecutionTransactions(
        matchedPairs,
        clearingPrice
      );

      console.log(`✅ Built ${transactions.length} transactions`);

      // ══════════════════════════════════════════════════════════════
      // STEP 3: Collect signatures from executors
      // ══════════════════════════════════════════════════════════════
      const signatures = await this.collectExecutorSignatures(
        transactions,
        proof
      );

      if (signatures.length < 3) {
        throw new Error(`Insufficient signatures (got ${signatures.length}, need 3)`);
      }

      console.log(`✅ Collected ${signatures.length} executor signatures`);

      // ══════════════════════════════════════════════════════════════
      // STEP 4: Submit transactions to Solana
      // ══════════════════════════════════════════════════════════════
      const txSignatures = await this.submitTransactions(transactions, signatures);

      console.log('✅ Transactions submitted to Solana');

      // ══════════════════════════════════════════════════════════════
      // STEP 5: Monitor settlement
      // ══════════════════════════════════════════════════════════════
      await this.monitorSettlement(txSignatures, matchedPairs);

      console.log('✅ All trades settled successfully\n');

      return {
        success: true,
        executedTrades: matchedPairs.length,
        txSignatures,
      };

    } catch (error) {
      console.error('❌ Execution failed:', error);
      throw error;
    }
  }

  /**
   * Build execution transactions using Jupiter
   */
  private async buildExecutionTransactions(
    matchedPairs: MatchedPair[],
    clearingPrice: number
  ): Promise<Transaction[]> {
    const transactions: Transaction[] = [];

    for (const pair of matchedPairs) {
      // Get Jupiter quote for swap
      const quote = await this.jupiter.getQuote({
        inputMint: 'So11111111111111111111111111111111111111112', // SOL
        outputMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
        amount: pair.amount * 1e9, // Convert to lamports
        slippageBps: 50, // 0.5% slippage
      });

      // Build swap transaction
      const transaction = await this.jupiter.buildSwapTransaction(quote, {
        userPublicKey: pair.buyOrder.walletAddress,
      });

      transactions.push(transaction);
    }

    return transactions;
  }

  /**
   * Collect signatures from executor nodes
   */
  private async collectExecutorSignatures(
    transactions: Transaction[],
    proof: MatchingProof
  ): Promise<ExecutorSignature[]> {
    const signaturePromises = this.executorUrls.map(async (url) => {
      try {
        const response = await fetch(`${url}/sign-execution`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            transactions: transactions.map(tx => tx.serialize().toString('base64')),
            matchProof: proof,
          }),
          timeout: 10000,
        });

        if (!response.ok) return null;

        return await response.json();
      } catch (error) {
        console.warn(`Executor ${url} failed to sign:`, error.message);
        return null;
      }
    });

    const results = await Promise.all(signaturePromises);
    return results.filter((sig): sig is ExecutorSignature => sig !== null);
  }

  /**
   * Submit transactions to Solana with executor signatures
   */
  private async submitTransactions(
    transactions: Transaction[],
    signatures: ExecutorSignature[]
  ): Promise<string[]> {
    const txSignatures: string[] = [];

    for (const transaction of transactions) {
      // Add executor signatures to transaction
      for (let i = 0; i < Math.min(3, signatures.length); i++) {
        transaction.addSignature(
          new PublicKey(signatures[i].publicKey),
          Buffer.from(signatures[i].signature, 'base64')
        );
      }

      // Submit transaction
      const signature = await this.solana.sendTransaction(transaction, {
        skipPreflight: false,
        commitment: 'confirmed',
      });

      txSignatures.push(signature);

      // Wait for confirmation
      await this.solana.confirmTransaction(signature, 'confirmed');
    }

    return txSignatures;
  }

  /**
   * Monitor settlement of trades
   */
  private async monitorSettlement(
    txSignatures: string[],
    matchedPairs: MatchedPair[]
  ): Promise<void> {
    // Update database with settlement status
    for (let i = 0; i < txSignatures.length; i++) {
      const signature = txSignatures[i];
      const pair = matchedPairs[i];

      await this.postgres.trade.create({
        data: {
          buyOrderHash: pair.buyOrder.orderHash,
          sellOrderHash: pair.sellOrder.orderHash,
          amount: pair.amount,
          price: pair.price,
          txSignature: signature,
          status: 'SETTLED',
          settledAt: new Date(),
        },
      });

      // Update order status
      await this.postgres.order.updateMany({
        where: {
          orderHash: {
            in: [pair.buyOrder.orderHash, pair.sellOrder.orderHash],
          },
        },
        data: {
          status: 'EXECUTED',
          executedAt: new Date(),
        },
      });
    }
  }

  private async validateMatchingProof(proof: MatchingProof): Promise<boolean> {
    const zkproof = new ZKProofService();
    return await zkproof.verifyProof(proof);
  }
}
```

═══════════════════════════════════════════════════════════════════════════════
# PART 6: JUPITER INTEGRATION
═══════════════════════════════════════════════════════════════════════════════

**File: `src/execution/jupiter.service.ts`**

```typescript
import { Jupiter, RouteInfo, SwapMode } from '@jup-ag/core';
import { Connection, PublicKey, Transaction } from '@solana/web3.js';

/**
 * Jupiter Aggregator integration for optimal swap routing
 * 
 * Jupiter provides:
 * - Best price discovery across all Solana DEXs
 * - Optimal routing through multiple pools
 * - Slippage protection
 * - MEV protection (already has some built-in)
 */
export class JupiterService {
  private jupiter: Jupiter;
  private connection: Connection;

  constructor(private solana: SolanaService) {
    this.connection = solana.getConnection();
  }

  async initialize() {
    // Initialize Jupiter instance
    this.jupiter = await Jupiter.load({
      connection: this.connection,
      cluster: 'mainnet-beta', // or 'devnet'
      user: PublicKey.default, // Will be overridden per swap
    });

    console.log('✅ Jupiter initialized');
  }

  /**
   * Get quote for token swap
   */
  async getQuote(params: {
    inputMint: string;
    outputMint: string;
    amount: number;
    slippageBps: number;
  }): Promise<RouteInfo> {
    const { inputMint, outputMint, amount, slippageBps } = params;

    const routes = await this.jupiter.computeRoutes({
      inputMint: new PublicKey(inputMint),
      outputMint: new PublicKey(outputMint),
      amount,
      slippageBps,
      forceFetch: true, // Get fresh quotes
    });

    if (routes.routesInfos.length === 0) {
      throw new Error('No routes found');
    }

    // Return best route (Jupiter sorts by output amount)
    return routes.routesInfos[0];
  }

  /**
   * Build swap transaction
   */
  async buildSwapTransaction(
    route: RouteInfo,
    options: {
      userPublicKey: string;
      wrapUnwrapSOL?: boolean;
    }
  ): Promise<Transaction> {
    const { userPublicKey, wrapUnwrapSOL = true } = options;

    const { execute } = await this.jupiter.exchange({
      routeInfo: route,
      userPublicKey: new PublicKey(userPublicKey),
      wrapUnwrapSOL,
    });

    // Get transaction without executing
    const { swapTransaction } = await execute({
      wallet: {
        signTransaction: async (tx) => tx, // Don't sign yet
        signAllTransactions: async (txs) => txs,
        publicKey: new PublicKey(userPublicKey),
      },
      simulate: true, // Only build, don't send
    });

    return swapTransaction;
  }

  /**
   * Execute swap (used for testing/simulation)
   */
  async executeSwap(
    route: RouteInfo,
    userPublicKey: string
  ): Promise<string> {
    const { execute } = await this.jupiter.exchange({
      routeInfo: route,
      userPublicKey: new PublicKey(userPublicKey),
    });

    const result = await execute();

    return result.txid;
  }

  /**
   * Get price impact for trade
   */
  getPriceImpact(route: RouteInfo): number {
    return route.priceImpactPct;
  }

  /**
   * Get route details (for transparency)
   */
  getRouteDetails(route: RouteInfo): {
    inputAmount: number;
    outputAmount: number;
    priceImpact: number;
    marketInfos: Array<{
      dex: string;
      inputMint: string;
      outputMint: string;
    }>;
  } {
    return {
      inputAmount: route.inAmount,
      outputAmount: route.outAmount,
      priceImpact: route.priceImpactPct,
      marketInfos: route.marketInfos.map(market => ({
        dex: market.label,
        inputMint: market.inputMint.toString(),
        outputMint: market.outputMint.toString(),
      })),
    };
  }
}
```

═══════════════════════════════════════════════════════════════════════════════
# PART 7: SOLANA SMART CONTRACT (ANCHOR)
═══════════════════════════════════════════════════════════════════════════════

**File: `src/blockchain/program/programs/phantompool/src/lib.rs`**

```rust
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod phantompool {
    use super::*;

    /**
     * Initialize PhantomPool program
     */
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let pool = &mut ctx.accounts.pool;
        pool.authority = ctx.accounts.authority.key();
        pool.total_volume = 0;
        pool.total_trades = 0;
        pool.bump = *ctx.bumps.get("pool").unwrap();
        
        msg!("PhantomPool initialized");
        Ok(())
    }

    /**
     * Execute matched trade
     * 
     * Called by executor coordinator after threshold decryption
     * Verifies ZK proof before execution
     */
    pub fn execute_trade(
        ctx: Context<ExecuteTrade>,
        amount: u64,
        clearing_price: u64,
        proof: Vec<u8>, // ZK proof
    ) -> Result<()> {
        // 1. Verify ZK proof
        require!(
            verify_zkproof(&proof),
            ErrorCode::InvalidProof
        );

        // 2. Transfer tokens from buyer to seller
        let cpi_accounts = Transfer {
            from: ctx.accounts.buyer_token_account.to_account_info(),
            to: ctx.accounts.seller_token_account.to_account_info(),
            authority: ctx.accounts.buyer.to_account_info(),
        };
        
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        
        token::transfer(cpi_ctx, amount)?;

        // 3. Update pool statistics
        let pool = &mut ctx.accounts.pool;
        pool.total_volume += amount;
        pool.total_trades += 1;

        // 4. Emit event
        emit!(TradeExecuted {
            buyer: ctx.accounts.buyer.key(),
            seller: ctx.accounts.seller.key(),
            amount,
            clearing_price,
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    /**
     * Settle batch of trades atomically
     * 
     * Ensures all trades in a matching round settle together
     */
    pub fn settle_batch(
        ctx: Context<SettleBatch>,
        trades: Vec<TradeInfo>,
    ) -> Result<()> {
        for trade in trades {
            // Execute each trade
            // All succeed or all fail (atomicity)
            msg!("Settling trade: {} tokens", trade.amount);
        }

        emit!(BatchSettled {
            trade_count: trades.len() as u64,
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }
}

// ══════════════════════════════════════════════════════════════
// ACCOUNT STRUCTURES
// ══════════════════════════════════════════════════════════════

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + PoolState::LEN,
        seeds = [b"pool"],
        bump
    )]
    pub pool: Account<'info, PoolState>,
    
    #[account(mut)]
    pub authority: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct ExecuteTrade<'info> {
    #[account(mut, seeds = [b"pool"], bump = pool.bump)]
    pub pool: Account<'info, PoolState>,
    
    #[account(mut)]
    pub buyer: Signer<'info>,
    
    /// CHECK: Seller account
    pub seller: AccountInfo<'info>,
    
    #[account(mut)]
    pub buyer_token_account: Account<'info, TokenAccount>,
    
    #[account(mut)]
    pub seller_token_account: Account<'info, TokenAccount>,
    
    pub token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct SettleBatch<'info> {
    #[account(mut, seeds = [b"pool"], bump = pool.bump)]
    pub pool: Account<'info, PoolState>,
    
    pub authority: Signer<'info>,
}

// ══════════════════════════════════════════════════════════════
// STATE
// ══════════════════════════════════════════════════════════════

#[account]
pub struct PoolState {
    pub authority: Pubkey,
    pub total_volume: u64,
    pub total_trades: u64,
    pub bump: u8,
}

impl PoolState {
    pub const LEN: usize = 32 + 8 + 8 + 1;
}

// ══════════════════════════════════════════════════════════════
// EVENTS
// ══════════════════════════════════════════════════════════════

#[event]
pub struct TradeExecuted {
    pub buyer: Pubkey,
    pub seller: Pubkey,
    pub amount: u64,
    pub clearing_price: u64,
    pub timestamp: i64,
}

#[event]
pub struct BatchSettled {
    pub trade_count: u64,
    pub timestamp: i64,
}

// ══════════════════════════════════════════════════════════════
// TYPES
// ══════════════════════════════════════════════════════════════

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct TradeInfo {
    pub buyer: Pubkey,
    pub seller: Pubkey,
    pub amount: u64,
    pub price: u64,
}

// ══════════════════════════════════════════════════════════════
// ERRORS
// ══════════════════════════════════════════════════════════════

#[error_code]
pub enum ErrorCode {
    #[msg("Invalid ZK proof")]
    InvalidProof,
    
    #[msg("Insufficient balance")]
    InsufficientBalance,
    
    #[msg("Trade already executed")]
    AlreadyExecuted,
}

// ══════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ══════════════════════════════════════════════════════════════

/**
 * Verify ZK proof (placeholder - integrate with actual ZK library)
 */
fn verify_zkproof(proof: &[u8]) -> bool {
    // In production: use groth16 or plonk verification
    // For now: basic validation
    !proof.is_empty()
}
```

**File: `src/blockchain/program/Anchor.toml`**

```toml
[features]
seeds = false
skip-lint = false

[programs.devnet]
phantompool = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "devnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
```

═══════════════════════════════════════════════════════════════════════════════
# PART 8: DATABASE SCHEMA & MODELS
═══════════════════════════════════════════════════════════════════════════════

**File: `prisma/schema.prisma`**

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ══════════════════════════════════════════════════════════════
// USER MODEL
// ══════════════════════════════════════════════════════════════

model User {
  id            String   @id @default(uuid())
  walletAddress String   @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  orders        Order[]
  trades        Trade[]
  
  // Statistics
  totalOrders   Int      @default(0)
  totalVolume   Decimal  @default(0) @db.Decimal(20, 8)
  
  @@index([walletAddress])
}

// ══════════════════════════════════════════════════════════════
// ORDER MODEL
// ══════════════════════════════════════════════════════════════

model Order {
  id                String   @id @default(uuid())
  orderHash         String   @unique
  walletAddress     String
  
  // Order details
  tokenPair         String   // e.g., "SOL/USDC"
  side              OrderSide
  encryptedAmount   Json     // { C1: ECPoint, C2: ECPoint }
  encryptedPrice    Json     // { C1: ECPoint, C2: ECPoint }
  
  // Status tracking
  status            OrderStatus @default(PENDING)
  submittedAt       DateTime    @default(now())
  matchedAt         DateTime?
  executedAt        DateTime?
  cancelledAt       DateTime?
  
  // Execution details
  clearingPrice     Decimal?    @db.Decimal(20, 8)
  txSignature       String?
  
  // Proofs
  solvencyProof     Json     // Bulletproofs+
  matchingProof     Json?    // ZK proof (after matching)
  
  // Relations
  user              User     @relation(fields: [walletAddress], references: [walletAddress])
  buyTrade          Trade?   @relation("BuyOrder")
  sellTrade         Trade?   @relation("SellOrder")
  
  @@index([orderHash])
  @@index([walletAddress])
  @@index([status])
  @@index([tokenPair, status])
  @@index([submittedAt])
}

enum OrderSide {
  BUY
  SELL
}

enum OrderStatus {
  PENDING       // Submitted, waiting for match
  MATCHED       // Matched with counterparty
  EXECUTED      // Executed on-chain
  CANCELLED     // Cancelled by user
  FAILED        // Execution failed
}

// ══════════════════════════════════════════════════════════════
// TRADE MODEL
// ══════════════════════════════════════════════════════════════

model Trade {
  id              String   @id @default(uuid())
  
  // Matched orders
  buyOrderHash    String   @unique
  sellOrderHash   String   @unique
  buyOrder        Order    @relation("BuyOrder", fields: [buyOrderHash], references: [orderHash])
  sellOrder       Order    @relation("SellOrder", fields: [sellOrderHash], references: [orderHash])
  
  // Trade details
  amount          Decimal  @db.Decimal(20, 8)
  price           Decimal  @db.Decimal(20, 8)  // Clearing price
  totalValue      Decimal  @db.Decimal(20, 8)  // amount * price
  
  // Execution
  txSignature     String?
  status          TradeStatus @default(PENDING)
  matchedAt       DateTime    @default(now())
  executedAt      DateTime?
  settledAt       DateTime?
  
  // Participants
  buyerAddress    String
  sellerAddress   String
  buyer           User     @relation(fields: [buyerAddress], references: [walletAddress])
  
  // Proofs
  matchingProof   Json     // ZK proof of correct matching
  executionProof  Json?    // ZK proof of correct execution
  
  @@index([buyOrderHash])
  @@index([sellOrderHash])
  @@index([status])
  @@index([matchedAt])
}

enum TradeStatus {
  PENDING       // Matched, awaiting execution
  EXECUTING     // Submitting to blockchain
  SETTLED       // Confirmed on-chain
  FAILED        // Execution failed
}

// ══════════════════════════════════════════════════════════════
// MATCHING ROUND MODEL
// ══════════════════════════════════════════════════════════════

model MatchingRound {
  id              String   @id @default(uuid())
  roundNumber     Int      @unique @default(autoincrement())
  
  // Round details
  tokenPair       String
  startedAt       DateTime @default(now())
  completedAt     DateTime?
  
  // Orders processed
  buyOrderCount   Int
  sellOrderCount  Int
  matchedCount    Int
  
  // Price discovery
  clearingPrice   Decimal? @db.Decimal(20, 8)
  totalVolume     Decimal? @db.Decimal(20, 8)
  
  // Cryptographic proofs
  vrfProof        Json     // VRF proof for shuffle
  shuffleProof    Json     // Proof of correct shuffle
  matchingProof   Json?    // ZK proof of correct matching
  
  // Executor signatures (threshold)
  executorSigs    Json     // Array of signatures from 3-of-5 executors
  
  status          RoundStatus @default(IN_PROGRESS)
  
  @@index([roundNumber])
  @@index([tokenPair])
  @@index([startedAt])
}

enum RoundStatus {
  IN_PROGRESS
  COMPLETED
  FAILED
}

// ══════════════════════════════════════════════════════════════
// EXECUTOR NODE MODEL
// ══════════════════════════════════════════════════════════════

model ExecutorNode {
  id              String   @id @default(uuid())
  executorId      Int      @unique
  
  // Network info
  url             String
  publicKey       String   // For signature verification
  
  // Status
  isActive        Boolean  @default(true)
  lastHeartbeat   DateTime @default(now())
  
  // Statistics
  totalDecryptions Int     @default(0)
  totalSignatures  Int     @default(0)
  uptime           Int     @default(0) // seconds
  
  createdAt       DateTime @default(now())
  
  @@index([executorId])
  @@index([isActive])
}

// ══════════════════════════════════════════════════════════════
// AUDIT LOG MODEL
// ══════════════════════════════════════════════════════════════

model AuditLog {
  id              String   @id @default(uuid())
  
  // Event details
  eventType       String   // e.g., "ORDER_SUBMITTED", "TRADE_EXECUTED"
  entityType      String   // e.g., "ORDER", "TRADE"
  entityId        String   // Order hash or trade ID
  
  // User info
  walletAddress   String?
  ipAddress       String?
  
  // Event data
  data            Json
  
  // Metadata
  timestamp       DateTime @default(now())
  
  @@index([eventType])
  @@index([walletAddress])
  @@index([timestamp])
}

// ══════════════════════════════════════════════════════════════
// CRYPTOGRAPHIC KEY MODEL
// ══════════════════════════════════════════════════════════════

model CryptoKey {
  id              String   @id @default(uuid())
  keyType         KeyType
  
  // Key data (encrypted at rest)
  publicKey       String
  privateKeyEnc   String?  // Encrypted with master key
  
  // Threshold shares (for ElGamal)
  shares          Json?    // Array of secret shares
  threshold       Int?     // Required shares
  totalShares     Int?     // Total shares
  
  // Metadata
  createdAt       DateTime @default(now())
  rotatedAt       DateTime?
  isActive        Boolean  @default(true)
  
  @@index([keyType, isActive])
}

enum KeyType {
  ELGAMAL
  VRF
  EXECUTOR
}
```

**File: `src/database/postgres/repositories/order.repository.ts`**

```typescript
import { PrismaClient, Order, OrderStatus } from '@prisma/client';

export class OrderRepository {
  constructor(private prisma: PrismaClient) {}

  /**
   * Create new order
   */
  async create(data: CreateOrderData): Promise<Order> {
    return await this.prisma.order.create({
      data: {
        orderHash: data.orderHash,
        walletAddress: data.walletAddress,
        tokenPair: data.tokenPair,
        side: data.side,
        encryptedAmount: data.encryptedAmount,
        encryptedPrice: data.encryptedPrice,
        solvencyProof: data.solvencyProof,
        status: 'PENDING',
      },
    });
  }

  /**
   * Get order by hash
   */
  async findByHash(orderHash: string): Promise<Order | null> {
    return await this.prisma.order.findUnique({
      where: { orderHash },
    });
  }

  /**
   * Get pending orders for token pair
   */
  async findPending(tokenPair: string): Promise<Order[]> {
    return await this.prisma.order.findMany({
      where: {
        tokenPair,
        status: 'PENDING',
      },
      orderBy: {
        submittedAt: 'asc',
      },
    });
  }

  /**
   * Update order status
   */
  async updateStatus(
    orderHash: string,
    status: OrderStatus,
    additionalData?: Partial<Order>
  ): Promise<Order> {
    return await this.prisma.order.update({
      where: { orderHash },
      data: {
        status,
        ...additionalData,
      },
    });
  }

  /**
   * Get user's orders
   */
  async findByWallet(
    walletAddress: string,
    limit: number = 50
  ): Promise<Order[]> {
    return await this.prisma.order.findMany({
      where: { walletAddress },
      orderBy: { submittedAt: 'desc' },
      take: limit,
    });
  }

  /**
   * Cancel order
   */
  async cancel(orderHash: string): Promise<Order> {
    return await this.prisma.order.update({
      where: { orderHash },
      data: {
        status: 'CANCELLED',
        cancelledAt: new Date(),
      },
    });
  }
}
```

═══════════════════════════════════════════════════════════════════════════════
# PART 9: API ENDPOINTS SPECIFICATION
═══════════════════════════════════════════════════════════════════════════════

**File: `src/api/routes/orders.routes.ts`**

```typescript
import { FastifyInstance } from 'fastify';
import { OrderController } from '../controllers/order.controller';

export async function ordersRoutes(fastify: FastifyInstance) {
  const controller = new OrderController(
    fastify.services.orderService,
    fastify.services.elgamal,
    fastify.services.bulletproofs
  );

  // ══════════════════════════════════════════════════════════════
  // POST /api/orders/submit - Submit new encrypted order
  // ══════════════════════════════════════════════════════════════
  fastify.post('/api/orders/submit', {
    schema: {
      body: {
        type: 'object',
        required: ['walletAddress', 'tokenPair', 'side', 'amount', 'limitPrice', 'balance', 'signature'],
        properties: {
          walletAddress: { type: 'string' },
          tokenPair: { type: 'string', enum: ['SOL/USDC'] },
          side: { type: 'string', enum: ['BUY', 'SELL'] },
          amount: { type: 'number', minimum: 0.1 },
          limitPrice: { type: 'number', minimum: 0 },
          balance: { type: 'number' },
          signature: { type: 'string' },
        },
      },
      response: {
        201: {
          type: 'object',
          properties: {
            success: { type: 'boolean' },
            orderHash: { type: 'string' },
            encryptedOrder: { type: 'object' },
            estimatedMatchTime: { type: 'number' },
          },
        },
      },
    },
  }, controller.submitOrder.bind(controller));

  // ══════════════════════════════════════════════════════════════
  // GET /api/orders/:orderHash - Get order status
  // ══════════════════════════════════════════════════════════════
  fastify.get('/api/orders/:orderHash', {
    schema: {
      params: {
        type: 'object',
        properties: {
          orderHash: { type: 'string' },
        },
      },
    },
  }, controller.getOrderStatus.bind(controller));

  // ══════════════════════════════════════════════════════════════
  // GET /api/orders/book/:tokenPair - Get order book
  // ══════════════════════════════════════════════════════════════
  fastify.get('/api/orders/book/:tokenPair', {
    schema: {
      params: {
        type: 'object',
        properties: {
          tokenPair: { type: 'string' },
        },
      },
    },
  }, controller.getOrderBook.bind(controller));

  // ══════════════════════════════════════════════════════════════
  // DELETE /api/orders/:orderHash - Cancel order
  // ══════════════════════════════════════════════════════════════
  fastify.delete('/api/orders/:orderHash', {
    schema: {
      params: {
        type: 'object',
        properties: {
          orderHash: { type: 'string' },
        },
      },
      body: {
        type: 'object',
        required: ['walletAddress', 'signature'],
        properties: {
          walletAddress: { type: 'string' },
          signature: { type: 'string' },
        },
      },
    },
  }, controller.cancelOrder.bind(controller));

  // ══════════════════════════════════════════════════════════════
  // GET /api/orders/wallet/:walletAddress - Get user's orders
  // ══════════════════════════════════════════════════════════════
  fastify.get('/api/orders/wallet/:walletAddress', async (request, reply) => {
    const { walletAddress } = request.params as any;
    const { limit = 50 } = request.query as any;

    const orders = await fastify.services.orderService.getUserOrders(
      walletAddress,
      limit
    );

    return reply.send({
      orders,
      count: orders.length,
    });
  });
}
```

**File: `src/api/routes/matching.routes.ts`**

```typescript
import { FastifyInstance } from 'fastify';

export async function matchingRoutes(fastify: FastifyInstance) {
  
  // ══════════════════════════════════════════════════════════════
  // GET /api/matching/status - Get current matching round status
  // ══════════════════════════════════════════════════════════════
  fastify.get('/api/matching/status', async (request, reply) => {
    const status = await fastify.services.matchingEngine.getStatus();

    return reply.send({
      isMatching: status.isMatching,
      nextRoundIn: status.nextRoundIn, // seconds
      lastRound: {
        completedAt: status.lastRound.completedAt,
        matchedOrders: status.lastRound.matchedOrders,
        clearingPrice: status.lastRound.clearingPrice,
      },
    });
  });

  // ══════════════════════════════════════════════════════════════
  // GET /api/matching/rounds/:roundNumber - Get round details
  // ══════════════════════════════════════════════════════════════
  fastify.get('/api/matching/rounds/:roundNumber', async (request, reply) => {
    const { roundNumber } = request.params as any;

    const round = await fastify.services.postgres.matchingRound.findUnique({
      where: { roundNumber: parseInt(roundNumber) },
    });

    if (!round) {
      return reply.code(404).send({ error: 'Round not found' });
    }

    return reply.send({
      roundNumber: round.roundNumber,
      tokenPair: round.tokenPair,
      startedAt: round.startedAt,
      completedAt: round.completedAt,
      orderCounts: {
        buy: round.buyOrderCount,
        sell: round.sellOrderCount,
        matched: round.matchedCount,
      },
      clearingPrice: round.clearingPrice,
      totalVolume: round.totalVolume,
      proofs: {
        vrf: round.vrfProof,
        shuffle: round.shuffleProof,
        matching: round.matchingProof,
      },
    });
  });

  // ══════════════════════════════════════════════════════════════
  // GET /api/matching/history - Get matching history
  // ══════════════════════════════════════════════════════════════
  fastify.get('/api/matching/history', async (request, reply) => {
    const { limit = 20 } = request.query as any;

    const rounds = await fastify.services.postgres.matchingRound.findMany({
      where: { status: 'COMPLETED' },
      orderBy: { roundNumber: 'desc' },
      take: limit,
    });

    return reply.send({
      rounds: rounds.map(r => ({
        roundNumber: r.roundNumber,
        tokenPair: r.tokenPair,
        completedAt: r.completedAt,
        matchedCount: r.matchedCount,
        clearingPrice: r.clearingPrice,
        totalVolume: r.totalVolume,
      })),
    });
  });
}
```

**File: `src/api/routes/proofs.routes.ts`**

```typescript
import { FastifyInstance } from 'fastify';

export async function proofsRoutes(fastify: FastifyInstance) {
  
  // ══════════════════════════════════════════════════════════════
  // POST /api/proofs/verify-solvency - Verify solvency proof
  // ══════════════════════════════════════════════════════════════
  fastify.post('/api/proofs/verify-solvency', async (request, reply) => {
    const { proof } = request.body as any;

    const isValid = await fastify.services.bulletproofs.verifySolvencyProof(proof);

    return reply.send({
      valid: isValid,
      timestamp: Date.now(),
    });
  });

  // ══════════════════════════════════════════════════════════════
  // POST /api/proofs/verify-matching - Verify matching proof
  // ══════════════════════════════════════════════════════════════
  fastify.post('/api/proofs/verify-matching', async (request, reply) => {
    const { proof } = request.body as any;

    const isValid = await fastify.services.zkproof.verifyProof(proof);

    return reply.send({
      valid: isValid,
      proofType: 'matching',
      timestamp: Date.now(),
    });
  });

  // ══════════════════════════════════════════════════════════════
  // POST /api/proofs/verify-vrf - Verify VRF proof
  // ══════════════════════════════════════════════════════════════
  fastify.post('/api/proofs/verify-vrf', async (request, reply) => {
    const { proof } = request.body as any;

    const isValid = await fastify.services.vrf.verifyVRFProof(proof);

    return reply.send({
      valid: isValid,
      proofType: 'vrf',
      randomness: proof.output,
      timestamp: Date.now(),
    });
  });

  // ══════════════════════════════════════════════════════════════
  // GET /api/proofs/order/:orderHash - Get all proofs for order
  // ══════════════════════════════════════════════════════════════
  fastify.get('/api/proofs/order/:orderHash', async (request, reply) => {
    const { orderHash } = request.params as any;

    const order = await fastify.services.postgres.order.findUnique({
      where: { orderHash },
      include: {
        buyTrade: true,
        sellTrade: true,
      },
    });

    if (!order) {
      return reply.code(404).send({ error: 'Order not found' });
    }

    return reply.send({
      orderHash,
      solvencyProof: order.solvencyProof,
      matchingProof: order.matchingProof,
      executionProof: order.buyTrade?.executionProof || order.sellTrade?.executionProof,
    });
  });
}
```

**File: `src/api/routes/analytics.routes.ts`**

```typescript
import { FastifyInstance } from 'fastify';

export async function analyticsRoutes(fastify: FastifyInstance) {
  
  // ══════════════════════════════════════════════════════════════
  // GET /api/analytics/volume - Get trading volume statistics
  // ══════════════════════════════════════════════════════════════
  fastify.get('/api/analytics/volume', async (request, reply) => {
    const { timeframe = '24h' } = request.query as any;

    const startTime = getStartTime(timeframe);

    const trades = await fastify.services.postgres.trade.findMany({
      where: {
        settledAt: {
          gte: startTime,
        },
      },
    });

    const totalVolume = trades.reduce((sum, trade) => sum + Number(trade.totalValue), 0);
    const averagePrice = trades.reduce((sum, trade) => sum + Number(trade.price), 0) / trades.length;

    return reply.send({
      timeframe,
      totalVolume,
      tradeCount: trades.length,
      averagePrice,
      startTime,
      endTime: new Date(),
    });
  });

  // ══════════════════════════════════════════════════════════════
  // GET /api/analytics/price-history - Get price history
  // ══════════════════════════════════════════════════════════════
  fastify.get('/api/analytics/price-history', async (request, reply) => {
    const { tokenPair = 'SOL/USDC', interval = '1h', limit = 100 } = request.query as any;

    const rounds = await fastify.services.postgres.matchingRound.findMany({
      where: {
        tokenPair,
        status: 'COMPLETED',
      },
      orderBy: { completedAt: 'desc' },
      take: limit,
    });

    const priceHistory = rounds.map(r => ({
      timestamp: r.completedAt,
      price: r.clearingPrice,
      volume: r.totalVolume,
    }));

    return reply.send({
      tokenPair,
      interval,
      data: priceHistory,
    });
  });

  // ══════════════════════════════════════════════════════════════
  // GET /api/analytics/executors - Get executor statistics
  // ══════════════════════════════════════════════════════════════
  fastify.get('/api/analytics/executors', async (request, reply) => {
    const executors = await fastify.services.postgres.executorNode.findMany({
      orderBy: { executorId: 'asc' },
    });

    return reply.send({
      executors: executors.map(e => ({
        executorId: e.executorId,
        isActive: e.isActive,
        lastHeartbeat: e.lastHeartbeat,
        uptime: e.uptime,
        totalDecryptions: e.totalDecryptions,
        totalSignatures: e.totalSignatures,
      })),
      activeCount: executors.filter(e => e.isActive).length,
      totalCount: executors.length,
    });
  });
}
```

═══════════════════════════════════════════════════════════════════════════════
# PART 10: SECURITY & ERROR HANDLING
═══════════════════════════════════════════════════════════════════════════════

**File: `src/api/middleware/auth.middleware.ts`**

```typescript
import { FastifyRequest, FastifyReply } from 'fastify';
import { verify } from '@noble/ed25519';
import { sha256 } from '@noble/hashes/sha256';

/**
 * Verify Solana wallet signature
 */
export async function authMiddleware(
  request: FastifyRequest,
  reply: FastifyReply
) {
  const { walletAddress, signature, message } = request.body as any;

  if (!walletAddress || !signature || !message) {
    return reply.code(401).send({
      error: 'Missing authentication parameters',
    });
  }

  try {
    // 1. Reconstruct message hash
    const messageHash = sha256(Buffer.from(message));

    // 2. Verify Ed25519 signature
    const publicKey = Buffer.from(walletAddress, 'base64');
    const sig = Buffer.from(signature, 'base64');

    const isValid = await verify(sig, messageHash, publicKey);

    if (!isValid) {
      return reply.code(401).send({
        error: 'Invalid signature',
      });
    }

    // 3. Check message timestamp (prevent replay attacks)
    const timestamp = extractTimestamp(message);
    const now = Date.now();
    
    if (Math.abs(now - timestamp) > 60000) { // 60 second window
      return reply.code(401).send({
        error: 'Signature expired',
      });
    }

    // Authentication successful
    request.user = { walletAddress };

  } catch (error) {
    request.log.error('Authentication failed:', error);
    return reply.code(401).send({
      error: 'Authentication failed',
    });
  }
}

function extractTimestamp(message: string): number {
  // Extract timestamp from message format: "PhantomPool-{timestamp}-{action}"
  const parts = message.split('-');
  return parseInt(parts[1]);
}
```

**File: `src/api/middleware/rateLimit.middleware.ts`**

```typescript
import { FastifyInstance } from 'fastify';
import rateLimit from '@fastify/rate-limit';

export async function registerRateLimiting(fastify: FastifyInstance) {
  // Global rate limit: 100 requests per minute per IP
  await fastify.register(rateLimit, {
    max: 100,
    timeWindow: '1 minute',
    redis: fastify.redis, // Use Redis for distributed rate limiting
  });

  // Strict rate limit for order submission: 10 per minute per wallet
  fastify.addHook('preHandler', async (request, reply) => {
    if (request.routerPath === '/api/orders/submit') {
      const { walletAddress } = request.body as any;
      
      const key = `ratelimit:orders:${walletAddress}`;
      const count = await fastify.redis.incr(key);
      
      if (count === 1) {
        await fastify.redis.expire(key, 60); // 60 seconds
      }
      
      if (count > 10) {
        return reply.code(429).send({
          error: 'Rate limit exceeded',
          message: 'Maximum 10 orders per minute',
        });
      }
    }
  });
}
```

**File: `src/api/middleware/error.middleware.ts`**

```typescript
import { FastifyError, FastifyRequest, FastifyReply } from 'fastify';
import { logger } from '../../monitoring/logger.service';

export async function errorHandler(
  error: FastifyError,
  request: FastifyRequest,
  reply: FastifyReply
) {
  // Log error
  logger.error('Request error:', {
    error: error.message,
    stack: error.stack,
    method: request.method,
    url: request.url,
    body: request.body,
  });

  // Send to Sentry
  if (process.env.SENTRY_DSN) {
    // Sentry.captureException(error);
  }

  // Don't expose internal errors to client
  if (error.statusCode && error.statusCode < 500) {
    return reply.code(error.statusCode).send({
      error: error.message,
      statusCode: error.statusCode,
    });
  }

  // Internal server error
  return reply.code(500).send({
    error: 'Internal server error',
    requestId: request.id,
  });
}
```

═══════════════════════════════════════════════════════════════════════════════
# PART 11: MONITORING & OBSERVABILITY
═══════════════════════════════════════════════════════════════════════════════

**File: `src/monitoring/metrics.service.ts`**

```typescript
import { register, Counter, Gauge, Histogram } from 'prom-client';
import express from 'express';

/**
 * Prometheus metrics for monitoring
 */
export class MetricsService {
  private app: express.Application;

  // Order metrics
  public orderSubmittedCounter = new Counter({
    name: 'phantompool_orders_submitted_total',
    help: 'Total number of orders submitted',
    labelNames: ['side', 'tokenPair'],
  });

  public orderMatchedCounter = new Counter({
    name: 'phantompool_orders_matched_total',
    help: 'Total number of orders matched',
    labelNames: ['tokenPair'],
  });

  public orderValueHistogram = new Histogram({
    name: 'phantompool_order_value_usdc',
    help: 'Distribution of order values in USDC',
    buckets: [100, 500, 1000, 5000, 10000, 50000, 100000],
  });

  // Matching metrics
  public matchingRoundCounter = new Counter({
    name: 'phantompool_matching_rounds_total',
    help: 'Total number of matching rounds',
  });

  public matchingDurationHistogram = new Histogram({
    name: 'phantompool_matching_duration_seconds',
    help: 'Duration of matching rounds',
    buckets: [1, 5, 10, 30, 60],
  });

  public clearingPriceGauge = new Gauge({
    name: 'phantompool_clearing_price',
    help: 'Current clearing price',
    labelNames: ['tokenPair'],
  });

  public matchedOrdersGauge = new Gauge({
    name: 'phantompool_matched_orders',
    help: 'Number of orders matched in last round',
  });

  // Execution metrics
  public tradesExecutedCounter = new Counter({
    name: 'phantompool_trades_executed_total',
    help: 'Total number of trades executed',
  });

  public executionDurationHistogram = new Histogram({
    name: 'phantompool_execution_duration_seconds',
    help: 'Duration of trade execution',
    buckets: [1, 5, 10, 30, 60],
  });

  // Cryptographic metrics
  public encryptionDurationHistogram = new Histogram({
    name: 'phantompool_encryption_duration_ms',
    help: 'Duration of order encryption',
    buckets: [10, 50, 100, 200, 500],
  });

  public decryptionDurationHistogram = new Histogram({
    name: 'phantompool_decryption_duration_ms',
    help: 'Duration of threshold decryption',
    buckets: [100, 500, 1000, 2000, 5000],
  });

  public proofGenerationHistogram = new Histogram({
    name: 'phantompool_proof_generation_ms',
    help: 'Duration of ZK proof generation',
    labelNames: ['proofType'],
    buckets: [100, 500, 1000, 5000, 10000],
  });

  public proofVerificationHistogram = new Histogram({
    name: 'phantompool_proof_verification_ms',
    help: 'Duration of proof verification',
    labelNames: ['proofType'],
    buckets: [1, 5, 10, 50, 100],
  });

  // Executor metrics
  public executorHealthGauge = new Gauge({
    name: 'phantompool_executor_health',
    help: 'Health status of executor nodes (1=healthy, 0=unhealthy)',
    labelNames: ['executorId'],
  });

  public executorDecryptionsCounter = new Counter({
    name: 'phantompool_executor_decryptions_total',
    help: 'Total partial decryptions by executor',
    labelNames: ['executorId'],
  });

  // System metrics
  public redisConnectionGauge = new Gauge({
    name: 'phantompool_redis_connected',
    help: 'Redis connection status',
  });

  public postgresConnectionGauge = new Gauge({
    name: 'phantompool_postgres_connected',
    help: 'Postgres connection status',
  });

  constructor() {
    this.app = express();
    this.setupMetricsEndpoint();
  }

  private setupMetricsEndpoint() {
    this.app.get('/metrics', async (req, res) => {
      res.set('Content-Type', register.contentType);
      res.end(await register.metrics());
    });
  }

  async start(port: number = 9090) {
    this.app.listen(port, () => {
      console.log(`📊 Metrics server running on port ${port}`);
    });
  }
}
```

**File: `src/monitoring/logger.service.ts`**

```typescript
import winston from 'winston';

/**
 * Structured logging with Winston
 */
export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'phantompool-backend' },
  transports: [
    // Console output (development)
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    }),
    
    // File output (production)
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log' 
    }),
  ],
});

// Add context to all logs
export function createContextLogger(context: string) {
  return {
    info: (message: string, meta?: any) => 
      logger.info(message, { context, ...meta }),
    error: (message: string, meta?: any) => 
      logger.error(message, { context, ...meta }),
    warn: (message: string, meta?: any) => 
      logger.warn(message, { context, ...meta }),
    debug: (message: string, meta?: any) => 
      logger.debug(message, { context, ...meta }),
  };
}
```

═══════════════════════════════════════════════════════════════════════════════
# PART 12: TESTING STRATEGY
═══════════════════════════════════════════════════════════════════════════════

**File: `tests/unit/crypto/elgamal.test.ts`**

```typescript
import { describe, it, expect, beforeAll } from '@jest/globals';
import { ElGamalService } from '../../../src/crypto/elgamal.service';

describe('ElGamal Encryption', () => {
  let elgamal: ElGamalService;
  let keypair: ElGamalKeyPair;

  beforeAll(async () => {
    elgamal = new ElGamalService();
    keypair = await elgamal.generateKeyPair();
  });

  it('should generate valid keypair', () => {
    expect(keypair.publicKey).toBeDefined();
    expect(keypair.privateKey).toBeDefined();
    expect(keypair.publicKey.x).toHaveLength(64); // 32 bytes in hex
  });

  it('should encrypt and decrypt order', async () => {
    const order = {
      walletAddress: 'TestWallet123',
      tokenPair: 'SOL/USDC',
      side: 'BUY' as const,
      amount: 100,
      limitPrice: 150,
      timestamp: Date.now(),
      nonce: 'test-nonce-123',
    };

    // Encrypt
    const encrypted = await elgamal.encryptOrder(order, keypair.publicKey);
    expect(encrypted.orderHash).toBeDefined();
    expect(encrypted.encryptedAmount).toBeDefined();
    expect(encrypted.encryptedPrice).toBeDefined();

    // Decrypt amount
    const decryptedAmount = await elgamal.decrypt(
      encrypted.encryptedAmount,
      keypair.privateKey
    );
    expect(decryptedAmount).toBe(order.amount);

    // Decrypt price
    const decryptedPrice = await elgamal.decrypt(
      encrypted.encryptedPrice,
      keypair.privateKey
    );
    expect(decryptedPrice).toBe(order.limitPrice);
  });

  it('should homomorphically aggregate orders', async () => {
    const orders = [
      { amount: 100, price: 150 },
      { amount: 50, price: 155 },
      { amount: 75, price: 148 },
    ];

    // Encrypt all orders
    const encryptedOrders = await Promise.all(
      orders.map(o => elgamal.encryptOrder({
        walletAddress: 'test',
        tokenPair: 'SOL/USDC',
        side: 'BUY',
        amount: o.amount,
        limitPrice: o.price,
        timestamp: Date.now(),
        nonce: Math.random().toString(),
      }, keypair.publicKey))
    );

    // Aggregate
    const aggregated = await elgamal.aggregateOrders(encryptedOrders);

    // Decrypt aggregated amount
    const totalAmount = await elgamal.decrypt(
      aggregated.buyVolume,
      keypair.privateKey
    );

    expect(totalAmount).toBe(100 + 50 + 75); // 225
  });

  it('should handle threshold decryption', async () => {
    // Generate secret shares
    const shares = await elgamal.prepareThresholdShares(
      BigInt(keypair.privateKey),
      3, // threshold
      5  // total shares
    );

    expect(shares).toHaveLength(5);

    // Encrypt a value
    const encrypted = await elgamal.encrypt(42, keypair.publicKey);

    // Get partial decryptions from 3 executors
    const partialDecryptions = await Promise.all(
      shares.slice(0, 3).map((share, i) =>
        elgamal.partialDecrypt(encrypted, share.share, i + 1)
      )
    );

    // Combine partial decryptions
    const decrypted = await elgamal.combinePartialDecryptions(
      partialDecryptions,
      encrypted
    );

    expect(decrypted.value).toBe(42);
  });
});
```

**File: `tests/unit/crypto/bulletproofs.test.ts`**

```typescript
import { describe, it, expect } from '@jest/globals';
import { BulletproofsService } from '../../../src/crypto/bulletproofs.service';

describe('Bulletproofs+ Solvency Proofs', () => {
  let bulletproofs: BulletproofsService;

  beforeAll(() => {
    bulletproofs = new BulletproofsService();
  });

  it('should generate and verify valid solvency proof', async () => {
    const balance = 10000;
    const requiredAmount = 5000;

    const proof = await bulletproofs.generateSolvencyProof(
      balance,
      requiredAmount
    );

    expect(proof.commitment).toBeDefined();
    expect(proof.proof).toBeDefined();

    const isValid = await bulletproofs.verifySolvencyProof(proof);
    expect(isValid).toBe(true);
  });

  it('should fail verification for insufficient balance', async () => {
    const balance = 3000;
    const requiredAmount = 5000;

    // Should throw or return invalid proof
    await expect(
      bulletproofs.generateSolvencyProof(balance, requiredAmount)
    ).rejects.toThrow();
  });

  it('should batch verify multiple proofs efficiently', async () => {
    const proofs = await Promise.all([
      bulletproofs.generateSolvencyProof(10000, 5000),
      bulletproofs.generateSolvencyProof(20000, 8000),
      bulletproofs.generateSolvencyProof(15000, 10000),
    ]);

    const startTime = Date.now();
    const result = await bulletproofs.batchVerifyProofs(proofs);
    const duration = Date.now() - startTime;

    expect(result.allValid).toBe(true);
    expect(duration).toBeLessThan(20); // Should be fast
  });
});
```

**File: `tests/integration/matching.test.ts`**

```typescript
import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';
import { MatchingEngineService } from '../../src/matching/engine.service';
import { setupTestEnvironment, cleanupTestEnvironment } from '../helpers';

describe('Matching Engine Integration', () => {
  let services: any;

  beforeAll(async () => {
    services = await setupTestEnvironment();
  });

  afterAll(async () => {
    await cleanupTestEnvironment();
  });

  it('should match orders at fair clearing price', async () => {
    // Submit buy orders
    const buyOrders = await Promise.all([
      services.orderService.submitOrder({
        walletAddress: 'buyer1',
        side: 'BUY',
        amount: 100,
        limitPrice: 155,
      }),
      services.orderService.submitOrder({
        walletAddress: 'buyer2',
        side: 'BUY',
        amount: 50,
        limitPrice: 152,
      }),
    ]);

    // Submit sell orders
    const sellOrders = await Promise.all([
      services.orderService.submitOrder({
        walletAddress: 'seller1',
        side: 'SELL',
        amount: 80,
        limitPrice: 148,
      }),
      services.orderService.submitOrder({
        walletAddress: 'seller2',
        side: 'SELL',
        amount: 70,
        limitPrice: 150,
      }),
    ]);

    // Run matching round
    await services.matchingEngine.runMatchingRound();

    // Verify matches
    const trades = await services.postgres.trade.findMany({
      where: {
        status: 'MATCHED',
      },
    });

    expect(trades.length).toBeGreaterThan(0);
    
    // All trades should be at same clearing price
    const clearingPrice = trades[0].price;
    trades.forEach(trade => {
      expect(trade.price).toBe(clearingPrice);
    });

    // Clearing price should be between min sell and max buy
    expect(Number(clearingPrice)).toBeGreaterThanOrEqual(148);
    expect(Number(clearingPrice)).toBeLessThanOrEqual(155);
  });

  it('should generate valid ZK proof for matching', async () => {
    // ... submit orders ...
    
    const result = await services.matchingEngine.runMatchingRound();

    expect(result.matchingProof).toBeDefined();

    // Verify proof
    const isValid = await services.zkproof.verifyProof(result.matchingProof);
    expect(isValid).toBe(true);
  });
});
```

**File: `tests/e2e/fullFlow.test.ts`**

```typescript
import { describe, it, expect } from '@jest/globals';

describe('End-to-End Flow', () => {
  it('should complete full order lifecycle', async () => {
    // 1. User submits encrypted order
    const orderResponse = await fetch('http://localhost:3000/api/orders/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        walletAddress: 'test-wallet',
        tokenPair: 'SOL/USDC',
        side: 'BUY',
        amount: 100,
        limitPrice: 150,
        balance: 20000,
        signature: 'test-signature',
      }),
    });

    expect(orderResponse.status).toBe(201);
    const { orderHash } = await orderResponse.json();

    // 2. Wait for matching round (30 seconds)
    await new Promise(resolve => setTimeout(resolve, 31000));

    // 3. Check order status
    const statusResponse = await fetch(
      `http://localhost:3000/api/orders/${orderHash}`
    );
    const status = await statusResponse.json();

    expect(status.status).toBeOneOf(['MATCHED', 'EXECUTED']);

    // 4. If executed, verify on Solana
    if (status.status === 'EXECUTED') {
      expect(status.txSignature).toBeDefined();
      
      // Verify transaction on Solana
      const solana = new Connection(process.env.SOLANA_RPC_URL);
      const tx = await solana.getTransaction(status.txSignature);
      
      expect(tx).toBeDefined();
      expect(tx.meta.err).toBeNull();
    }
  });
});
```

═══════════════════════════════════════════════════════════════════════════════
# PART 13: DEPLOYMENT & DEVOPS
═══════════════════════════════════════════════════════════════════════════════

**File: `docker/Dockerfile.api`**

```dockerfile
FROM node:20-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci

# Copy source
COPY . .

# Build TypeScript
RUN npm run build

# Production image
FROM node:20-alpine

WORKDIR /app

# Copy built files
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

USER nodejs

EXPOSE 3000

CMD ["node", "dist/index.js"]
```

**File: `docker/docker-compose.yml`**

```yaml
version: '3.8'

services:
  # ══════════════════════════════════════════════════════════════
  # PostgreSQL Database
  # ══════════════════════════════════════════════════════════════
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: phantompool
      POSTGRES_USER: phantompool
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U phantompool"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ══════════════════════════════════════════════════════════════
  # Redis Cache
  # ══════════════════════════════════════════════════════════════
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ══════════════════════════════════════════════════════════════
  # API Server
  # ══════════════════════════════════════════════════════════════
  api:
    build:
      context: ..
      dockerfile: docker/Dockerfile.api
    ports:
      - "3000:3000"
      - "9090:9090"  # Metrics
    environment:
      DATABASE_URL: postgresql://phantompool:${POSTGRES_PASSWORD}@postgres:5432/phantompool
      REDIS_URL: redis://redis:6379
      SOLANA_RPC_URL: ${SOLANA_RPC_URL}
      NODE_ENV: production
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  # ══════════════════════════════════════════════════════════════
  # Executor Nodes (5 instances)
  # ══════════════════════════════════════════════════════════════
  executor-1:
    build:
      context: ..
      dockerfile: docker/Dockerfile.executor
    ports:
      - "4001:4001"
    environment:
      EXECUTOR_ID: 1
      EXECUTOR_PORT: 4001
      SECRET_SHARE: ${EXECUTOR_1_SHARE}
    depends_on:
      - api

  executor-2:
    build:
      context: ..
      dockerfile: docker/Dockerfile.executor
    ports:
      - "4002:4002"
    environment:
      EXECUTOR_ID: 2
      EXECUTOR_PORT: 4002
      SECRET_SHARE: ${EXECUTOR_2_SHARE}
    depends_on:
      - api

  executor-3:
    build:
      context: ..
      dockerfile: docker/Dockerfile.executor
    ports:
      - "4003:4003"
    environment:
      EXECUTOR_ID: 3
      EXECUTOR_PORT: 4003
      SECRET_SHARE: ${EXECUTOR_3_SHARE}
    depends_on:
      - api

  executor-4:
    build:
      context: ..
      dockerfile: docker/Dockerfile.executor
    ports:
      - "4004:4004"
    environment:
      EXECUTOR_ID: 4
      EXECUTOR_PORT: 4004
      SECRET_SHARE: ${EXECUTOR_4_SHARE}
    depends_on:
      - api

  executor-5:
    build:
      context: ..
      dockerfile: docker/Dockerfile.executor
    ports:
      - "4005:4005"
    environment:
      EXECUTOR_ID: 5
      EXECUTOR_PORT: 4005
      SECRET_SHARE: ${EXECUTOR_5_SHARE}
    depends_on:
      - api

  # ══════════════════════════════════════════════════════════════
  # Monitoring: Prometheus
  # ══════════════════════════════════════════════════════════════
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9091:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'

  # ══════════════════════════════════════════════════════════════
  # Monitoring: Grafana
  # ══════════════════════════════════════════════════════════════
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3001:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
    depends_on:
      - prometheus

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:
```

**File: `k8s/api-deployment.yaml`**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: phantompool-api
  namespace: phantompool
spec:
  replicas: 3
  selector:
    matchLabels:
      app: phantompool-api
  template:
    metadata:
      labels:
        app: phantompool-api
    spec:
      containers:
      - name: api
        image: phantompool/api:latest
        ports:
        - containerPort: 3000
        - containerPort: 9090
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: phantompool-secrets
              key: database-url
        - name: REDIS_URL
          value: redis://redis-service:6379
        - name: SOLANA_RPC_URL
          valueFrom:
            configMapKeyRef:
              name: phantompool-config
              key: solana-rpc-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: phantompool-api-service
  namespace: phantompool
spec:
  selector:
    app: phantompool-api
  ports:
  - name: http
    port: 80
    targetPort: 3000
  - name: metrics
    port: 9090
    targetPort: 9090
  type: LoadBalancer
```

**File: `.env.example`**

```bash
# Database
DATABASE_URL=postgresql://phantompool:password@localhost:5432/phantompool
POSTGRES_PASSWORD=your_secure_password

# Redis
REDIS_URL=redis://localhost:6379

# Solana
SOLANA_RPC_URL=https://api.devnet.solana.com
SOLANA_NETWORK=devnet

# Cryptography
ELGAMAL_PRIVATE_KEY=  # Generated via setup script
VRF_PRIVATE_KEY=      # Generated via setup script

# Executor Secret Shares (3-of-5 threshold)
EXECUTOR_1_SHARE=  # Generated via setup script
EXECUTOR_2_SHARE=
EXECUTOR_3_SHARE=
EXECUTOR_4_SHARE=
EXECUTOR_5_SHARE=

# API
PORT=3000
NODE_ENV=development
LOG_LEVEL=debug

# Monitoring
GRAFANA_PASSWORD=admin
SENTRY_DSN=  # Optional

# Security
JWT_SECRET=your_jwt_secret
RATE_LIMIT_MAX=100
```

**File: `scripts/setup-executors.ts`**

```typescript
/**
 * Setup script to initialize 5 executor nodes with threshold shares
 * 
 * Run: ts-node scripts/setup-executors.ts
 */

import { ElGamalService } from '../src/crypto/elgamal.service';
import { writeFileSync } from 'fs';

async function setup() {
  console.log('🔧 Setting up PhantomPool executor network...\n');

  // 1. Generate ElGamal keypair
  console.log('1. Generating ElGamal keypair...');
  const elgamal = new ElGamalService();
  const keypair = await elgamal.generateKeyPair();
  
  console.log(`✅ Public key: ${keypair.publicKey.x}`);
  console.log(`✅ Private key: ${keypair.privateKey.substring(0, 10)}...`);

  // 2. Generate secret shares (3-of-5)
  console.log('\n2. Generating threshold secret shares (3-of-5)...');
  const shares = await elgamal.prepareThresholdShares(
    BigInt(keypair.privateKey),
    3, // threshold
    5  // total shares
  );

  console.log(`✅ Generated ${shares.length} secret shares`);

  // 3. Write to .env file
  console.log('\n3. Writing configuration to .env...');
  const envContent = `
# ElGamal Keys (Generated: ${new Date().toISOString()})
ELGAMAL_PUBLIC_KEY_X=${keypair.publicKey.x}
ELGAMAL_PUBLIC_KEY_Y=${keypair.publicKey.y}
ELGAMAL_PRIVATE_KEY=${keypair.privateKey}

# Executor Secret Shares (3-of-5 Threshold)
EXECUTOR_1_SHARE=${shares[0].share.toString(16)}
EXECUTOR_2_SHARE=${shares[1].share.toString(16)}
EXECUTOR_3_SHARE=${shares[2].share.toString(16)}
EXECUTOR_4_SHARE=${shares[3].share.toString(16)}
EXECUTOR_5_SHARE=${shares[4].share.toString(16)}
`;

  writeFileSync('.env.generated', envContent);
  console.log('✅ Configuration written to .env.generated');

  console.log('\n✨ Setup complete!');
  console.log('\nNext steps:');
  console.log('1. Copy .env.generated to .env');
  console.log('2. Update other environment variables in .env');
  console.log('3. Run: npm run dev');
}

setup().catch(console.error);
```

═══════════════════════════════════════════════════════════════════════════════
# FINAL IMPLEMENTATION CHECKLIST
═══════════════════════════════════════════════════════════════════════════════

## Core Cryptography ✓
- [ ] ElGamal encryption/decryption
- [ ] Homomorphic order aggregation
- [ ] Threshold secret sharing (3-of-5)
- [ ] Partial decryption protocol
- [ ] Bulletproofs+ solvency proofs
- [ ] VRF for fair ordering
- [ ] ZK proof generation (Groth16/PLONK)
- [ ] Proof verification

## Backend Services ✓
- [ ] Order submission API
- [ ] Encrypted order book (Redis)
- [ ] Matching engine (30s intervals)
- [ ] Clearing price calculation
- [ ] Executor coordinator
- [ ] 5 executor node services
- [ ] Jupiter integration
- [ ] Solana transaction building

## Database ✓
- [ ] PostgreSQL schema
- [ ] Order model
- [ ] Trade model
- [ ] Matching round model
- [ ] Audit log model
- [ ] Repositories

## Smart Contract ✓
- [ ] Anchor program
- [ ] Trade execution instruction
- [ ] Batch settlement
- [ ] ZK proof verification
- [ ] Event emissions

## Security ✓
- [ ] Wallet signature verification
- [ ] Rate limiting
- [ ] Input validation
- [ ] Error handling
- [ ] Audit logging

## Monitoring ✓
- [ ] Prometheus metrics
- [ ] Winston logging
- [ ] Grafana dashboards
- [ ] Health checks
- [ ] Performance tracking

## Testing ✓
- [ ] Unit tests (crypto)
- [ ] Integration tests (matching)
- [ ] E2E tests (full flow)
- [ ] Load testing
- [ ] Security testing

## Deployment ✓
- [ ] Docker containers
- [ ] docker-compose setup
- [ ] Kubernetes manifests
- [ ] Environment configuration
- [ ] Setup scripts
- [ ] CI/CD pipeline

═══════════════════════════════════════════════════════════════════════════════
# PART 14: ADDITIONAL IMPLEMENTATION DETAILS
═══════════════════════════════════════════════════════════════════════════════

## 14.1 REDIS ORDERBOOK IMPLEMENTATION

**File: `src/database/redis/orderbook.cache.ts`**

```typescript
import { Redis } from 'ioredis';
import { EncryptedOrder } from '../../types';

/**
 * High-performance in-memory order book using Redis
 */
export class OrderBookCache {
  constructor(private redis: Redis) {}

  /**
   * Add order to order book
   * Uses Redis Sorted Sets for efficient time-ordered retrieval
   */
  async addOrder(order: EncryptedOrder): Promise<void> {
    const key = this.getOrderBookKey(order.tokenPair, order.side);
    
    // Store order in sorted set (sorted by timestamp)
    await this.redis.zadd(
      key,
      order.timestamp,
      JSON.stringify(order)
    );

    // Set order hash index for quick lookup
    await this.redis.setex(
      `order:${order.orderHash}`,
      3600, // 1 hour TTL
      JSON.stringify(order)
    );

    // Increment order count
    await this.redis.incr(`stats:orders:${order.side}`);
  }

  /**
   * Get all orders for matching
   */
  async getOrdersForMatching(tokenPair: string): Promise<{
    buys: EncryptedOrder[];
    sells: EncryptedOrder[];
  }> {
    const [buysRaw, sellsRaw] = await Promise.all([
      this.redis.zrange(this.getOrderBookKey(tokenPair, 'BUY'), 0, -1),
      this.redis.zrange(this.getOrderBookKey(tokenPair, 'SELL'), 0, -1),
    ]);

    return {
      buys: buysRaw.map(r => JSON.parse(r)),
      sells: sellsRaw.map(r => JSON.parse(r)),
    };
  }

  /**
   * Remove orders after matching (atomic operation)
   */
  async removeOrders(orderHashes: string[], tokenPair: string): Promise<void> {
    const pipeline = this.redis.pipeline();

    for (const hash of orderHashes) {
      // Get order to determine its side
      const orderData = await this.redis.get(`order:${hash}`);
      if (orderData) {
        const order = JSON.parse(orderData);
        const key = this.getOrderBookKey(tokenPair, order.side);
        
        // Remove from sorted set
        pipeline.zrem(key, orderData);
        
        // Remove index
        pipeline.del(`order:${hash}`);
      }
    }

    await pipeline.exec();
  }

  /**
   * Get order book depth (for display)
   */
  async getOrderBookDepth(tokenPair: string, levels: number = 10): Promise<{
    bids: Array<{ price: string; volume: number; orders: number }>;
    asks: Array<{ price: string; volume: number; orders: number }>;
  }> {
    // This requires decrypting prices, which is done via threshold decryption
    // For now, return encrypted view
    const buys = await this.redis.zrange(
      this.getOrderBookKey(tokenPair, 'BUY'),
      0,
      levels - 1
    );
    const sells = await this.redis.zrange(
      this.getOrderBookKey(tokenPair, 'SELL'),
      0,
      levels - 1
    );

    return {
      bids: buys.map(b => {
        const order = JSON.parse(b);
        return {
          price: 'ENCRYPTED', // Would be decrypted for authorized viewers
          volume: 0, // Encrypted
          orders: 1,
        };
      }),
      asks: sells.map(s => {
        const order = JSON.parse(s);
        return {
          price: 'ENCRYPTED',
          volume: 0,
          orders: 1,
        };
      }),
    };
  }

  /**
   * Clear old orders (cleanup job)
   */
  async cleanupStaleOrders(maxAge: number = 3600000): Promise<number> {
    const cutoffTime = Date.now() - maxAge;
    let removed = 0;

    for (const side of ['BUY', 'SELL']) {
      for (const pair of ['SOL/USDC', 'SOL/USDT']) {
        const key = this.getOrderBookKey(pair, side as any);
        
        // Remove orders older than cutoff
        const count = await this.redis.zremrangebyscore(
          key,
          '-inf',
          cutoffTime
        );
        
        removed += count;
      }
    }

    return removed;
  }

  private getOrderBookKey(tokenPair: string, side: 'BUY' | 'SELL'): string {
    return `orderbook:${tokenPair}:${side}`;
  }
}
```

## 14.2 WEBSOCKET REAL-TIME UPDATES

**File: `src/api/websocket.service.ts`**

```typescript
import { Server } from 'socket.io';
import { Server as HTTPServer } from 'http';

/**
 * WebSocket service for real-time updates to frontend
 */
export class WebSocketService {
  private io: Server;

  constructor(httpServer: HTTPServer) {
    this.io = new Server(httpServer, {
      cors: {
        origin: process.env.FRONTEND_URL || '*',
        methods: ['GET', 'POST'],
      },
    });

    this.setupEventHandlers();
  }

  private setupEventHandlers() {
    this.io.on('connection', (socket) => {
      console.log(`Client connected: ${socket.id}`);

      // Subscribe to order book updates
      socket.on('subscribe:orderbook', (tokenPair: string) => {
        socket.join(`orderbook:${tokenPair}`);
        console.log(`Client ${socket.id} subscribed to ${tokenPair}`);
      });

      // Subscribe to matching rounds
      socket.on('subscribe:matching', () => {
        socket.join('matching');
        console.log(`Client ${socket.id} subscribed to matching updates`);
      });

      // Subscribe to user's orders
      socket.on('subscribe:orders', (walletAddress: string) => {
        socket.join(`orders:${walletAddress}`);
        console.log(`Client ${socket.id} subscribed to orders for ${walletAddress}`);
      });

      socket.on('disconnect', () => {
        console.log(`Client disconnected: ${socket.id}`);
      });
    });
  }

  /**
   * Emit new order received
   */
  emitOrderReceived(order: EncryptedOrder) {
    this.io.to(`orderbook:${order.tokenPair}`).emit('order:new', {
      orderHash: order.orderHash,
      side: order.side,
      timestamp: order.timestamp,
    });
  }

  /**
   * Emit matching round started
   */
  emitMatchingStarted(roundNumber: number, tokenPair: string) {
    this.io.to('matching').emit('matching:started', {
      roundNumber,
      tokenPair,
      timestamp: Date.now(),
    });
  }

  /**
   * Emit matching completed
   */
  emitMatchingCompleted(roundNumber: number, data: {
    clearingPrice: number;
    matchedCount: number;
    totalVolume: number;
  }) {
    this.io.to('matching').emit('matching:completed', {
      roundNumber,
      ...data,
      timestamp: Date.now(),
    });
  }

  /**
   * Emit order matched
   */
  emitOrderMatched(orderHash: string, walletAddress: string, clearingPrice: number) {
    this.io.to(`orders:${walletAddress}`).emit('order:matched', {
      orderHash,
      clearingPrice,
      timestamp: Date.now(),
    });
  }

  /**
   * Emit order executed
   */
  emitOrderExecuted(orderHash: string, walletAddress: string, txSignature: string) {
    this.io.to(`orders:${walletAddress}`).emit('order:executed', {
      orderHash,
      txSignature,
      timestamp: Date.now(),
    });
  }

  /**
   * Emit VRF shuffle animation
   */
  emitVRFShuffle(vrfProof: VRFProof) {
    this.io.to('matching').emit('vrf:shuffle', {
      proof: vrfProof,
      timestamp: Date.now(),
    });
  }

  /**
   * Emit executor status update
   */
  emitExecutorStatus(executorId: number, status: 'online' | 'offline') {
    this.io.emit('executor:status', {
      executorId,
      status,
      timestamp: Date.now(),
    });
  }
}
```

## 14.3 CONFIGURATION MANAGEMENT

**File: `src/config/env.config.ts`**

```typescript
import { config } from 'dotenv';
import { z } from 'zod';

// Load environment variables
config();

/**
 * Environment variable schema validation
 */
const envSchema = z.object({
  // Database
  DATABASE_URL: z.string().url(),
  REDIS_URL: z.string().url(),

  // Solana
  SOLANA_RPC_URL: z.string().url(),
  SOLANA_NETWORK: z.enum(['devnet', 'testnet', 'mainnet-beta']),

  // Cryptography
  ELGAMAL_PRIVATE_KEY: z.string().min(64),
  VRF_PRIVATE_KEY: z.string().min(64),

  // Executor shares
  EXECUTOR_1_SHARE: z.string().optional(),
  EXECUTOR_2_SHARE: z.string().optional(),
  EXECUTOR_3_SHARE: z.string().optional(),
  EXECUTOR_4_SHARE: z.string().optional(),
  EXECUTOR_5_SHARE: z.string().optional(),

  // API
  PORT: z.string().default('3000').transform(Number),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info'),

  // Security
  JWT_SECRET: z.string().min(32).optional(),
  RATE_LIMIT_MAX: z.string().default('100').transform(Number),

  // Monitoring
  SENTRY_DSN: z.string().url().optional(),
  GRAFANA_PASSWORD: z.string().optional(),

  // Frontend
  FRONTEND_URL: z.string().url().optional(),
});

// Validate and export config
export const Config = envSchema.parse(process.env);

// Type-safe config
export type AppConfig = z.infer<typeof envSchema>;

/**
 * Get executor shares as array
 */
export function getExecutorShares(): string[] {
  return [
    Config.EXECUTOR_1_SHARE,
    Config.EXECUTOR_2_SHARE,
    Config.EXECUTOR_3_SHARE,
    Config.EXECUTOR_4_SHARE,
    Config.EXECUTOR_5_SHARE,
  ].filter((share): share is string => share !== undefined);
}

/**
 * Validate configuration on startup
 */
export function validateConfig() {
  try {
    envSchema.parse(process.env);
    console.log('✅ Configuration validated successfully');
  } catch (error) {
    console.error('❌ Configuration validation failed:', error);
    process.exit(1);
  }
}
```

## 14.4 UTILITY FUNCTIONS

**File: `src/utils/encoding.utils.ts`**

```typescript
import { Buffer } from 'buffer';

/**
 * Convert hex string to Buffer
 */
export function hexToBuffer(hex: string): Buffer {
  return Buffer.from(hex.replace(/^0x/, ''), 'hex');
}

/**
 * Convert Buffer to hex string
 */
export function bufferToHex(buffer: Buffer): string {
  return '0x' + buffer.toString('hex');
}

/**
 * Convert ECPoint to hex string
 */
export function pointToHex(point: ECPoint): string {
  return `04${point.x}${point.y}`; // Uncompressed format
}

/**
 * Parse hex string to ECPoint
 */
export function hexToPoint(hex: string): ECPoint {
  const clean = hex.replace(/^0x|^04/, '');
  const x = clean.substring(0, 64);
  const y = clean.substring(64, 128);
  
  return { x, y };
}

/**
 * Encode order data for hashing
 */
export function encodeOrderData(order: PlainOrder): Buffer {
  const parts = [
    order.walletAddress,
    order.tokenPair,
    order.side,
    order.amount.toString(),
    order.limitPrice.toString(),
    order.timestamp.toString(),
    order.nonce,
  ];
  
  return Buffer.from(parts.join('|'), 'utf8');
}

/**
 * Generate order hash
 */
export function generateOrderHash(order: PlainOrder): string {
  const crypto = require('crypto');
  const data = encodeOrderData(order);
  return crypto.createHash('sha256').update(data).digest('hex');
}

/**
 * Base64 encode
 */
export function toBase64(data: Uint8Array | Buffer): string {
  return Buffer.from(data).toString('base64');
}

/**
 * Base64 decode
 */
export function fromBase64(encoded: string): Buffer {
  return Buffer.from(encoded, 'base64');
}
```

**File: `src/utils/validation.utils.ts`**

```typescript
import { PublicKey } from '@solana/web3.js';

/**
 * Validate Solana wallet address
 */
export function isValidWalletAddress(address: string): boolean {
  try {
    new PublicKey(address);
    return true;
  } catch {
    return false;
  }
}

/**
 * Validate order amount
 */
export function isValidOrderAmount(amount: number, tokenPair: string): boolean {
  // Minimum order sizes
  const minimums: Record<string, number> = {
    'SOL/USDC': 0.1, // 0.1 SOL minimum
    'SOL/USDT': 0.1,
  };

  const min = minimums[tokenPair] || 0.1;
  return amount >= min && amount <= 1000000; // Max 1M
}

/**
 * Validate price
 */
export function isValidPrice(price: number): boolean {
  return price > 0 && price < 1000000 && Number.isFinite(price);
}

/**
 * Validate signature format
 */
export function isValidSignature(signature: string): boolean {
  try {
    const buf = Buffer.from(signature, 'base64');
    return buf.length === 64; // Ed25519 signature length
  } catch {
    return false;
  }
}

/**
 * Sanitize user input
 */
export function sanitizeInput(input: string): string {
  return input
    .trim()
    .replace(/[<>]/g, '') // Remove HTML tags
    .substring(0, 1000); // Limit length
}
```

**File: `src/utils/math.utils.ts`**

```typescript
/**
 * BigInt arithmetic helpers for cryptographic operations
 */

/**
 * Modular exponentiation: (base^exponent) mod modulus
 */
export function modPow(base: bigint, exponent: bigint, modulus: bigint): bigint {
  if (modulus === 1n) return 0n;
  
  let result = 1n;
  base = base % modulus;
  
  while (exponent > 0n) {
    if (exponent % 2n === 1n) {
      result = (result * base) % modulus;
    }
    exponent = exponent / 2n;
    base = (base * base) % modulus;
  }
  
  return result;
}

/**
 * Modular inverse: find x such that (a * x) mod m = 1
 */
export function modInverse(a: bigint, m: bigint): bigint {
  const [gcd, x] = extendedGCD(a, m);
  
  if (gcd !== 1n) {
    throw new Error('Modular inverse does not exist');
  }
  
  return (x % m + m) % m;
}

/**
 * Extended Euclidean algorithm
 */
function extendedGCD(a: bigint, b: bigint): [bigint, bigint, bigint] {
  if (b === 0n) {
    return [a, 1n, 0n];
  }
  
  const [gcd, x1, y1] = extendedGCD(b, a % b);
  const x = y1;
  const y = x1 - (a / b) * y1;
  
  return [gcd, x, y];
}

/**
 * Random bigint in range [min, max)
 */
export function randomBigInt(min: bigint, max: bigint): bigint {
  const range = max - min;
  const bits = range.toString(2).length;
  const bytes = Math.ceil(bits / 8);
  
  let random: bigint;
  do {
    const buffer = crypto.getRandomValues(new Uint8Array(bytes));
    random = BigInt('0x' + Buffer.from(buffer).toString('hex'));
  } while (random >= range);
  
  return random + min;
}

/**
 * Lagrange interpolation coefficient
 */
export function lagrangeCoefficient(
  i: number,
  shares: number[],
  modulus: bigint
): bigint {
  let numerator = 1n;
  let denominator = 1n;
  
  for (const j of shares) {
    if (i !== j) {
      numerator = (numerator * BigInt(j)) % modulus;
      denominator = (denominator * BigInt(j - i)) % modulus;
    }
  }
  
  return (numerator * modInverse(denominator, modulus)) % modulus;
}

/**
 * Convert number to fixed-point representation
 */
export function toFixedPoint(value: number, decimals: number = 6): bigint {
  return BigInt(Math.round(value * Math.pow(10, decimals)));
}

/**
 * Convert fixed-point to number
 */
export function fromFixedPoint(value: bigint, decimals: number = 6): number {
  return Number(value) / Math.pow(10, decimals);
}
```

## 14.5 ERROR CLASSES

**File: `src/utils/errors.ts`**

```typescript
/**
 * Custom error classes for better error handling
 */

export class PhantomPoolError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'PhantomPoolError';
  }
}

export class CryptographicError extends PhantomPoolError {
  constructor(message: string) {
    super(message, 'CRYPTO_ERROR');
    this.name = 'CryptographicError';
  }
}

export class InvalidProofError extends PhantomPoolError {
  constructor(proofType: string) {
    super(`Invalid ${proofType} proof`, 'INVALID_PROOF');
    this.name = 'InvalidProofError';
  }
}

export class InsufficientBalanceError extends PhantomPoolError {
  constructor(required: number, available: number) {
    super(
      `Insufficient balance: required ${required}, available ${available}`,
      'INSUFFICIENT_BALANCE'
    );
    this.name = 'InsufficientBalanceError';
  }
}

export class OrderNotFoundError extends PhantomPoolError {
  constructor(orderHash: string) {
    super(`Order not found: ${orderHash}`, 'ORDER_NOT_FOUND');
    this.name = 'OrderNotFoundError';
  }
}

export class MatchingError extends PhantomPoolError {
  constructor(message: string) {
    super(message, 'MATCHING_ERROR');
    this.name = 'MatchingError';
  }
}

export class ExecutionError extends PhantomPoolError {
  constructor(message: string) {
    super(message, 'EXECUTION_ERROR');
    this.name = 'ExecutionError';
  }
}

export class ThresholdError extends PhantomPoolError {
  constructor(available: number, required: number) {
    super(
      `Insufficient executors: ${available}/${required}`,
      'THRESHOLD_ERROR'
    );
    this.name = 'ThresholdError';
  }
}
```

## 14.6 PERFORMANCE OPTIMIZATION

**File: `src/services/cache.service.ts`**

```typescript
import { Redis } from 'ioredis';

/**
 * Caching service for performance optimization
 */
export class CacheService {
  constructor(private redis: Redis) {}

  /**
   * Cache ElGamal public key
   */
  async cachePublicKey(publicKey: ECPoint): Promise<void> {
    await this.redis.setex(
      'crypto:elgamal:publickey',
      86400, // 24 hours
      JSON.stringify(publicKey)
    );
  }

  /**
   * Get cached public key
   */
  async getCachedPublicKey(): Promise<ECPoint | null> {
    const cached = await this.redis.get('crypto:elgamal:publickey');
    return cached ? JSON.parse(cached) : null;
  }

  /**
   * Cache VRF proof for verification
   */
  async cacheVRFProof(roundNumber: number, proof: VRFProof): Promise<void> {
    await this.redis.setex(
      `vrf:round:${roundNumber}`,
      3600, // 1 hour
      JSON.stringify(proof)
    );
  }

  /**
   * Cache matching result
   */
  async cacheMatchingResult(roundNumber: number, result: any): Promise<void> {
    await this.redis.setex(
      `matching:result:${roundNumber}`,
      3600,
      JSON.stringify(result)
    );
  }

  /**
   * Batch get orders (reduces round trips)
   */
  async batchGetOrders(orderHashes: string[]): Promise<(EncryptedOrder | null)[]> {
    const pipeline = this.redis.pipeline();
    
    orderHashes.forEach(hash => {
      pipeline.get(`order:${hash}`);
    });
    
    const results = await pipeline.exec();
    
    return results.map(([err, data]) => {
      if (err || !data) return null;
      return JSON.parse(data as string);
    });
  }

  /**
   * Cache clearing price for analytics
   */
  async cacheClearingPrice(tokenPair: string, price: number): Promise<void> {
    await this.redis.lpush(`prices:${tokenPair}`, price);
    await this.redis.ltrim(`prices:${tokenPair}`, 0, 999); // Keep last 1000
  }

  /**
   * Get price history from cache
   */
  async getPriceHistory(tokenPair: string, limit: number = 100): Promise<number[]> {
    const prices = await this.redis.lrange(`prices:${tokenPair}`, 0, limit - 1);
    return prices.map(p => parseFloat(p));
  }
}
```

## 14.7 BACKGROUND JOBS

**File: `src/jobs/cleanup.job.ts`**

```typescript
import { CronJob } from 'cron';
import { OrderBookCache } from '../database/redis/orderbook.cache';
import { PrismaClient } from '@prisma/client';

/**
 * Background jobs for system maintenance
 */
export class CleanupJob {
  constructor(
    private orderbook: OrderBookCache,
    private postgres: PrismaClient
  ) {}

  /**
   * Start all cleanup jobs
   */
  start() {
    // Clean stale orders every hour
    new CronJob('0 * * * *', async () => {
      await this.cleanStaleOrders();
    }).start();

    // Archive old trades every day at 2 AM
    new CronJob('0 2 * * *', async () => {
      await this.archiveOldTrades();
    }).start();

    // Update executor health every 30 seconds
    new CronJob('*/30 * * * * *', async () => {
      await this.checkExecutorHealth();
    }).start();

    console.log('✅ Background jobs started');
  }

  private async cleanStaleOrders() {
    console.log('🧹 Cleaning stale orders...');
    
    const removed = await this.orderbook.cleanupStaleOrders(3600000); // 1 hour
    
    console.log(`✅ Removed ${removed} stale orders`);
  }

  private async archiveOldTrades() {
    console.log('📦 Archiving old trades...');
    
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - 30); // 30 days ago
    
    const archived = await this.postgres.trade.updateMany({
      where: {
        settledAt: {
          lt: cutoffDate,
        },
        status: 'SETTLED',
      },
      data: {
        // Move to archive table or mark as archived
        // archived: true,
      },
    });
    
    console.log(`✅ Archived ${archived.count} trades`);
  }

  private async checkExecutorHealth() {
    const executors = await this.postgres.executorNode.findMany();
    
    const now = Date.now();
    const threshold = 60000; // 60 seconds
    
    for (const executor of executors) {
      const timeSinceHeartbeat = now - executor.lastHeartbeat.getTime();
      const isHealthy = timeSinceHeartbeat < threshold;
      
      if (executor.isActive !== isHealthy) {
        await this.postgres.executorNode.update({
          where: { id: executor.id },
          data: { isActive: isHealthy },
        });
        
        console.log(`Executor ${executor.executorId}: ${isHealthy ? 'online' : 'offline'}`);
      }
    }
  }
}
```

═══════════════════════════════════════════════════════════════════════════════

This completes the comprehensive PhantomPool backend implementation prompt.

## SUMMARY

The system provides:
✅ **Zero-knowledge privacy** via ElGamal homomorphic encryption
✅ **Provable fairness** via VRF shuffle  
✅ **Trustless execution** via 3-of-5 threshold decryption
✅ **Transparent verification** via ZK proofs
✅ **Production-ready architecture** with monitoring, testing, and deployment
✅ **Real-time updates** via WebSockets
✅ **High performance** with Redis caching
✅ **Comprehensive error handling** and validation
✅ **Background jobs** for system maintenance
✅ **Full observability** with metrics and logging

**Total Implementation**: ~12,000 lines of detailed specifications
**Cryptographic Systems**: 4 (ElGamal, Bulletproofs+, VRF, ZK Proofs)
**Services**: 15+ microservices
**Database Models**: 7 main models
**API Endpoints**: 20+ endpoints
**Test Coverage**: Unit, Integration, E2E

Ready for implementation by Claude Sonnet 4 or GitHub Copilot!